// Copyright Microsoft Corporation
// Copyright Oberon microsystems, Inc
// Copyright GHI Electronics, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <algorithm>
#include <string.h>
#include "LPC24.h"

///////////////////////////////////////////////////////////////////////////////

#ifdef INCLUDE_CAN

#define LPC24_CAN_RX_BUFFER_DEFAULT_SIZE 128

#define CAN_TRANSFER_TIMEOUT 0xFFFF

#define CAN_MEM_BASE        0xE0038000

/* Acceptance filter mode in AFMR register */
#define ACCF_OFF                0x01
#define ACCF_BYPASS                0x02
#define ACCF_ON                    0x00
#define ACCF_FULLCAN            0x04

/* This number applies to all FULLCAN IDs, explicit STD IDs, group STD IDs,
explicit EXT IDs, and group EXT IDs. */
#define ACCF_IDEN_NUM            4

/* Identifiers for FULLCAN, EXP STD, GRP STD, EXP EXT, GRP EXT */
#define FULLCAN_ID                0x100
#define EXP_STD_ID                0x100
#define GRP_STD_ID                0x200
#define EXP_EXT_ID                0x100000
#define GRP_EXT_ID                0x200000

// #define CAN_BASE 0x40038000

#define AFMR (*(volatile unsigned long *)0xE003C000)
#define AFMR_OFFSET 0x4000
#define AFMR_AccOff_MASK 0x1
#define AFMR_AccOff 0x1
#define AFMR_AccOff_BIT 0
#define AFMR_AccBP_MASK 0x2
#define AFMR_AccBP 0x2
#define AFMR_AccBP_BIT 1
#define AFMR_eFCAN_MASK 0x4
#define AFMR_eFCAN 0x4
#define AFMR_eFCAN_BIT 2

#define SFF_sa (*(volatile unsigned long *)0xE003C004)
#define SFF_sa_OFFSET 0x4004

#define SFF_GRP_sa (*(volatile unsigned long *)0xE003C008)
#define SFF_GRP_sa_OFFSET 0x4008

#define EFF_sa (*(volatile unsigned long *)0xE003C00C)
#define EFF_sa_OFFSET 0x400C

#define EFF_GRP_sa (*(volatile unsigned long *)0xE003C010)
#define EFF_GRP_sa_OFFSET 0x4010

#define ENDofTable (*(volatile unsigned long *)0xE003C014)
#define ENDofTable_OFFSET 0x4014

#define LUTerrAd (*(volatile unsigned long *)0xE003C018)
#define LUTerrAd_OFFSET 0x4018

#define LUTerr (*(volatile unsigned long *)0xE003C01C)
#define LUTerr_OFFSET 0x401C

#define FCANIE (*(volatile unsigned long *)0xE003C020)
#define FCANIE_OFFSET 0x4020
#define FCANIE_FCANIE_MASK 0x1
#define FCANIE_FCANIE 0x1
#define FCANIE_FCANIE_BIT 0

#define FCANIC0 (*(volatile unsigned long *)0xE003C024)
#define FCANIC0_OFFSET 0x4024
#define FCANIC0_IntPnd0_MASK 0x1
#define FCANIC0_IntPnd0 0x1
#define FCANIC0_IntPnd0_BIT 0
#define FCANIC0_IntPnd1_MASK 0x2
#define FCANIC0_IntPnd1 0x2
#define FCANIC0_IntPnd1_BIT 1
#define FCANIC0_IntPnd2_MASK 0x4
#define FCANIC0_IntPnd2 0x4
#define FCANIC0_IntPnd2_BIT 2
#define FCANIC0_IntPnd3_MASK 0x8
#define FCANIC0_IntPnd3 0x8
#define FCANIC0_IntPnd3_BIT 3
#define FCANIC0_IntPnd4_MASK 0x10
#define FCANIC0_IntPnd4 0x10
#define FCANIC0_IntPnd4_BIT 4
#define FCANIC0_IntPnd5_MASK 0x20
#define FCANIC0_IntPnd5 0x20
#define FCANIC0_IntPnd5_BIT 5
#define FCANIC0_IntPnd6_MASK 0x40
#define FCANIC0_IntPnd6 0x40
#define FCANIC0_IntPnd6_BIT 6
#define FCANIC0_IntPnd7_MASK 0x80
#define FCANIC0_IntPnd7 0x80
#define FCANIC0_IntPnd7_BIT 7
#define FCANIC0_IntPnd8_MASK 0x100
#define FCANIC0_IntPnd8 0x100
#define FCANIC0_IntPnd8_BIT 8
#define FCANIC0_IntPnd9_MASK 0x200
#define FCANIC0_IntPnd9 0x200
#define FCANIC0_IntPnd9_BIT 9
#define FCANIC0_IntPnd10_MASK 0x400
#define FCANIC0_IntPnd10 0x400
#define FCANIC0_IntPnd10_BIT 10
#define FCANIC0_IntPnd11_MASK 0x800
#define FCANIC0_IntPnd11 0x800
#define FCANIC0_IntPnd11_BIT 11
#define FCANIC0_IntPnd12_MASK 0x1000
#define FCANIC0_IntPnd12 0x1000
#define FCANIC0_IntPnd12_BIT 12
#define FCANIC0_IntPnd13_MASK 0x2000
#define FCANIC0_IntPnd13 0x2000
#define FCANIC0_IntPnd13_BIT 13
#define FCANIC0_IntPnd14_MASK 0x4000
#define FCANIC0_IntPnd14 0x4000
#define FCANIC0_IntPnd14_BIT 14
#define FCANIC0_IntPnd15_MASK 0x8000
#define FCANIC0_IntPnd15 0x8000
#define FCANIC0_IntPnd15_BIT 15
#define FCANIC0_IntPnd16_MASK 0x10000
#define FCANIC0_IntPnd16 0x10000
#define FCANIC0_IntPnd16_BIT 16
#define FCANIC0_IntPnd17_MASK 0x20000
#define FCANIC0_IntPnd17 0x20000
#define FCANIC0_IntPnd17_BIT 17
#define FCANIC0_IntPnd18_MASK 0x40000
#define FCANIC0_IntPnd18 0x40000
#define FCANIC0_IntPnd18_BIT 18
#define FCANIC0_IntPnd19_MASK 0x80000
#define FCANIC0_IntPnd19 0x80000
#define FCANIC0_IntPnd19_BIT 19
#define FCANIC0_IntPnd20_MASK 0x100000
#define FCANIC0_IntPnd20 0x100000
#define FCANIC0_IntPnd20_BIT 20
#define FCANIC0_IntPnd21_MASK 0x200000
#define FCANIC0_IntPnd21 0x200000
#define FCANIC0_IntPnd21_BIT 21
#define FCANIC0_IntPnd22_MASK 0x400000
#define FCANIC0_IntPnd22 0x400000
#define FCANIC0_IntPnd22_BIT 22
#define FCANIC0_IntPnd23_MASK 0x800000
#define FCANIC0_IntPnd23 0x800000
#define FCANIC0_IntPnd23_BIT 23
#define FCANIC0_IntPnd24_MASK 0x1000000
#define FCANIC0_IntPnd24 0x1000000
#define FCANIC0_IntPnd24_BIT 24
#define FCANIC0_IntPnd25_MASK 0x2000000
#define FCANIC0_IntPnd25 0x2000000
#define FCANIC0_IntPnd25_BIT 25
#define FCANIC0_IntPnd26_MASK 0x4000000
#define FCANIC0_IntPnd26 0x4000000
#define FCANIC0_IntPnd26_BIT 26
#define FCANIC0_IntPnd27_MASK 0x8000000
#define FCANIC0_IntPnd27 0x8000000
#define FCANIC0_IntPnd27_BIT 27
#define FCANIC0_IntPnd28_MASK 0x10000000
#define FCANIC0_IntPnd28 0x10000000
#define FCANIC0_IntPnd28_BIT 28
#define FCANIC0_IntPnd29_MASK 0x20000000
#define FCANIC0_IntPnd29 0x20000000
#define FCANIC0_IntPnd29_BIT 29
#define FCANIC0_IntPnd30_MASK 0x40000000
#define FCANIC0_IntPnd30 0x40000000
#define FCANIC0_IntPnd30_BIT 30
#define FCANIC0_IntPnd31_MASK 0x80000000
#define FCANIC0_IntPnd31 0x80000000
#define FCANIC0_IntPnd31_BIT 31

#define FCANIC1 (*(volatile unsigned long *)0xE003C028)
#define FCANIC1_OFFSET 0x4028
#define FCANIC1_IntPnd32_MASK 0x1
#define FCANIC1_IntPnd32 0x1
#define FCANIC1_IntPnd32_BIT 0
#define FCANIC1_IntPnd33_MASK 0x2
#define FCANIC1_IntPnd33 0x2
#define FCANIC1_IntPnd33_BIT 1
#define FCANIC1_IntPnd34_MASK 0x4
#define FCANIC1_IntPnd34 0x4
#define FCANIC1_IntPnd34_BIT 2
#define FCANIC1_IntPnd35_MASK 0x8
#define FCANIC1_IntPnd35 0x8
#define FCANIC1_IntPnd35_BIT 3
#define FCANIC1_IntPnd36_MASK 0x10
#define FCANIC1_IntPnd36 0x10
#define FCANIC1_IntPnd36_BIT 4
#define FCANIC1_IntPnd37_MASK 0x20
#define FCANIC1_IntPnd37 0x20
#define FCANIC1_IntPnd37_BIT 5
#define FCANIC1_IntPnd38_MASK 0x40
#define FCANIC1_IntPnd38 0x40
#define FCANIC1_IntPnd38_BIT 6
#define FCANIC1_IntPnd39_MASK 0x80
#define FCANIC1_IntPnd39 0x80
#define FCANIC1_IntPnd39_BIT 7
#define FCANIC1_IntPnd40_MASK 0x100
#define FCANIC1_IntPnd40 0x100
#define FCANIC1_IntPnd40_BIT 8
#define FCANIC1_IntPnd41_MASK 0x200
#define FCANIC1_IntPnd41 0x200
#define FCANIC1_IntPnd41_BIT 9
#define FCANIC1_IntPnd42_MASK 0x400
#define FCANIC1_IntPnd42 0x400
#define FCANIC1_IntPnd42_BIT 10
#define FCANIC1_IntPnd43_MASK 0x800
#define FCANIC1_IntPnd43 0x800
#define FCANIC1_IntPnd43_BIT 11
#define FCANIC1_IntPnd44_MASK 0x1000
#define FCANIC1_IntPnd44 0x1000
#define FCANIC1_IntPnd44_BIT 12
#define FCANIC1_IntPnd45_MASK 0x2000
#define FCANIC1_IntPnd45 0x2000
#define FCANIC1_IntPnd45_BIT 13
#define FCANIC1_IntPnd46_MASK 0x4000
#define FCANIC1_IntPnd46 0x4000
#define FCANIC1_IntPnd46_BIT 14
#define FCANIC1_IntPnd47_MASK 0x8000
#define FCANIC1_IntPnd47 0x8000
#define FCANIC1_IntPnd47_BIT 15
#define FCANIC1_IntPnd48_MASK 0x10000
#define FCANIC1_IntPnd48 0x10000
#define FCANIC1_IntPnd48_BIT 16
#define FCANIC1_IntPnd49_MASK 0x20000
#define FCANIC1_IntPnd49 0x20000
#define FCANIC1_IntPnd49_BIT 17
#define FCANIC1_IntPnd50_MASK 0x40000
#define FCANIC1_IntPnd50 0x40000
#define FCANIC1_IntPnd50_BIT 18
#define FCANIC1_IntPnd51_MASK 0x80000
#define FCANIC1_IntPnd51 0x80000
#define FCANIC1_IntPnd51_BIT 19
#define FCANIC1_IntPnd52_MASK 0x100000
#define FCANIC1_IntPnd52 0x100000
#define FCANIC1_IntPnd52_BIT 20
#define FCANIC1_IntPnd53_MASK 0x200000
#define FCANIC1_IntPnd53 0x200000
#define FCANIC1_IntPnd53_BIT 21
#define FCANIC1_IntPnd54_MASK 0x400000
#define FCANIC1_IntPnd54 0x400000
#define FCANIC1_IntPnd54_BIT 22
#define FCANIC1_IntPnd55_MASK 0x800000
#define FCANIC1_IntPnd55 0x800000
#define FCANIC1_IntPnd55_BIT 23
#define FCANIC1_IntPnd56_MASK 0x1000000
#define FCANIC1_IntPnd56 0x1000000
#define FCANIC1_IntPnd56_BIT 24
#define FCANIC1_IntPnd57_MASK 0x2000000
#define FCANIC1_IntPnd57 0x2000000
#define FCANIC1_IntPnd57_BIT 25
#define FCANIC1_IntPnd58_MASK 0x4000000
#define FCANIC1_IntPnd58 0x4000000
#define FCANIC1_IntPnd58_BIT 26
#define FCANIC1_IntPnd59_MASK 0x8000000
#define FCANIC1_IntPnd59 0x8000000
#define FCANIC1_IntPnd59_BIT 27
#define FCANIC1_IntPnd60_MASK 0x10000000
#define FCANIC1_IntPnd60 0x10000000
#define FCANIC1_IntPnd60_BIT 28
#define FCANIC1_IntPnd61_MASK 0x20000000
#define FCANIC1_IntPnd61 0x20000000
#define FCANIC1_IntPnd61_BIT 29
#define FCANIC1_IntPnd62_MASK 0x40000000
#define FCANIC1_IntPnd62 0x40000000
#define FCANIC1_IntPnd62_BIT 30
#define FCANIC1_IntPnd63_MASK 0x80000000
#define FCANIC1_IntPnd63 0x80000000
#define FCANIC1_IntPnd63_BIT 31

#define CANTxSR (*(volatile unsigned long *)0xE0040000)
#define CANTxSR_OFFSET 0x8000
#define CANTxSR_TS1_MASK 0x1
#define CANTxSR_TS1 0x1
#define CANTxSR_TS1_BIT 0
#define CANTxSR_TS2_MASK 0x2
#define CANTxSR_TS2 0x2
#define CANTxSR_TS2_BIT 1
#define CANTxSR_TBS1_MASK 0x100
#define CANTxSR_TBS1 0x100
#define CANTxSR_TBS1_BIT 8
#define CANTxSR_TBS2_MASK 0x200
#define CANTxSR_TBS2 0x200
#define CANTxSR_TBS2_BIT 9
#define CANTxSR_TCS1_MASK 0x10000
#define CANTxSR_TCS1 0x10000
#define CANTxSR_TCS1_BIT 16
#define CANTxSR_TCS2_MASK 0x20000
#define CANTxSR_TCS2 0x20000
#define CANTxSR_TCS2_BIT 17

#define CANRxSR (*(volatile unsigned long *)0xE0040004)
#define CANRxSR_OFFSET 0x8004
#define CANRxSR_RS1_MASK 0x1
#define CANRxSR_RS1 0x1
#define CANRxSR_RS1_BIT 0
#define CANRxSR_RS2_MASK 0x2
#define CANRxSR_RS2 0x2
#define CANRxSR_RS2_BIT 1
#define CANRxSR_RB1_MASK 0x100
#define CANRxSR_RB1 0x100
#define CANRxSR_RB1_BIT 8
#define CANRxSR_RB2_MASK 0x200
#define CANRxSR_RB2 0x200
#define CANRxSR_RB2_BIT 9
#define CANRxSR_DOS1_MASK 0x10000
#define CANRxSR_DOS1 0x10000
#define CANRxSR_DOS1_BIT 16
#define CANRxSR_DOS2_MASK 0x20000
#define CANRxSR_DOS2 0x20000
#define CANRxSR_DOS2_BIT 17

#define CANMSR (*(volatile unsigned long *)0xE0040008)
#define CANMSR_OFFSET 0x8008
#define CANMSR_ES1_MASK 0x1
#define CANMSR_ES1 0x1
#define CANMSR_ES1_BIT 0
#define CANMSR_ES2_MASK 0x2
#define CANMSR_ES2 0x2
#define CANMSR_ES2_BIT 1
#define CANMSR_BS1_MASK 0x100
#define CANMSR_BS1 0x100
#define CANMSR_BS1_BIT 8
#define CANMSR_BS2_MASK 0x200
#define CANMSR_BS2 0x200
#define CANMSR_BS2_BIT 9

#define CAN1_BASE 0xE0044000

#define C1MOD (*(volatile unsigned long *)0xE0044000)
#define CAN1MOD C1MOD
#define C1MOD_OFFSET 0x0
#define CAN1MOD_OFFSET C1MOD_OFFSET
#define C1MOD_RM_MASK 0x1
#define CAN1MOD_RM_MASK C1MOD_RM_MASK
#define C1MOD_RM 0x1
#define CAN1MOD_RM C1MOD_RM
#define C1MOD_RM_BIT 0
#define CAN1MOD_RM_BIT C1MOD_RM_BIT
#define C1MOD_LOM_MASK 0x2
#define CAN1MOD_LOM_MASK C1MOD_LOM_MASK
#define C1MOD_LOM 0x2
#define CAN1MOD_LOM C1MOD_LOM
#define C1MOD_LOM_BIT 1
#define CAN1MOD_LOM_BIT C1MOD_LOM_BIT
#define C1MOD_STM_MASK 0x4
#define CAN1MOD_STM_MASK C1MOD_STM_MASK
#define C1MOD_STM 0x4
#define CAN1MOD_STM C1MOD_STM
#define C1MOD_STM_BIT 2
#define CAN1MOD_STM_BIT C1MOD_STM_BIT
#define C1MOD_TPM_MASK 0x8
#define CAN1MOD_TPM_MASK C1MOD_TPM_MASK
#define C1MOD_TPM 0x8
#define CAN1MOD_TPM C1MOD_TPM
#define C1MOD_TPM_BIT 3
#define CAN1MOD_TPM_BIT C1MOD_TPM_BIT
#define C1MOD_SM_MASK 0x10
#define CAN1MOD_SM_MASK C1MOD_SM_MASK
#define C1MOD_SM 0x10
#define CAN1MOD_SM C1MOD_SM
#define C1MOD_SM_BIT 4
#define CAN1MOD_SM_BIT C1MOD_SM_BIT
#define C1MOD_RPM_MASK 0x20
#define CAN1MOD_RPM_MASK C1MOD_RPM_MASK
#define C1MOD_RPM 0x20
#define CAN1MOD_RPM C1MOD_RPM
#define C1MOD_RPM_BIT 5
#define CAN1MOD_RPM_BIT C1MOD_RPM_BIT
#define C1MOD_TM_MASK 0x80
#define CAN1MOD_TM_MASK C1MOD_TM_MASK
#define C1MOD_TM 0x80
#define CAN1MOD_TM C1MOD_TM
#define C1MOD_TM_BIT 7
#define CAN1MOD_TM_BIT C1MOD_TM_BIT

#define C1CMR (*(volatile unsigned long *)0xE0044004)
#define CAN1CMR C1CMR
#define C1CMR_OFFSET 0x4
#define CAN1CMR_OFFSET C1CMR_OFFSET
#define C1CMR_TR_MASK 0x1
#define CAN1CMR_TR_MASK C1CMR_TR_MASK
#define C1CMR_TR 0x1
#define CAN1CMR_TR C1CMR_TR
#define C1CMR_TR_BIT 0
#define CAN1CMR_TR_BIT C1CMR_TR_BIT
#define C1CMR_AT_MASK 0x2
#define CAN1CMR_AT_MASK C1CMR_AT_MASK
#define C1CMR_AT 0x2
#define CAN1CMR_AT C1CMR_AT
#define C1CMR_AT_BIT 1
#define CAN1CMR_AT_BIT C1CMR_AT_BIT
#define C1CMR_RRB_MASK 0x4
#define CAN1CMR_RRB_MASK C1CMR_RRB_MASK
#define C1CMR_RRB 0x4
#define CAN1CMR_RRB C1CMR_RRB
#define C1CMR_RRB_BIT 2
#define CAN1CMR_RRB_BIT C1CMR_RRB_BIT
#define C1CMR_CDO_MASK 0x8
#define CAN1CMR_CDO_MASK C1CMR_CDO_MASK
#define C1CMR_CDO 0x8
#define CAN1CMR_CDO C1CMR_CDO
#define C1CMR_CDO_BIT 3
#define CAN1CMR_CDO_BIT C1CMR_CDO_BIT
#define C1CMR_SRR_MASK 0x10
#define CAN1CMR_SRR_MASK C1CMR_SRR_MASK
#define C1CMR_SRR 0x10
#define CAN1CMR_SRR C1CMR_SRR
#define C1CMR_SRR_BIT 4
#define CAN1CMR_SRR_BIT C1CMR_SRR_BIT
#define C1CMR_STB1_MASK 0x20
#define CAN1CMR_STB1_MASK C1CMR_STB1_MASK
#define C1CMR_STB1 0x20
#define CAN1CMR_STB1 C1CMR_STB1
#define C1CMR_STB1_BIT 5
#define CAN1CMR_STB1_BIT C1CMR_STB1_BIT
#define C1CMR_STB2_MASK 0x40
#define CAN1CMR_STB2_MASK C1CMR_STB2_MASK
#define C1CMR_STB2 0x40
#define CAN1CMR_STB2 C1CMR_STB2
#define C1CMR_STB2_BIT 6
#define CAN1CMR_STB2_BIT C1CMR_STB2_BIT
#define C1CMR_STB3_MASK 0x80
#define CAN1CMR_STB3_MASK C1CMR_STB3_MASK
#define C1CMR_STB3 0x80
#define CAN1CMR_STB3 C1CMR_STB3
#define C1CMR_STB3_BIT 7
#define CAN1CMR_STB3_BIT C1CMR_STB3_BIT

#define C1GSR (*(volatile unsigned long *)0xE0044008)
#define CAN1GSR C1GSR
#define C1GSR_OFFSET 0x8
#define CAN1GSR_OFFSET C1GSR_OFFSET
#define C1GSR_RBS_MASK 0x1
#define CAN1GSR_RBS_MASK C1GSR_RBS_MASK
#define C1GSR_RBS 0x1
#define CAN1GSR_RBS C1GSR_RBS
#define C1GSR_RBS_BIT 0
#define CAN1GSR_RBS_BIT C1GSR_RBS_BIT
#define C1GSR_DOS_MASK 0x2
#define CAN1GSR_DOS_MASK C1GSR_DOS_MASK
#define C1GSR_DOS 0x2
#define CAN1GSR_DOS C1GSR_DOS
#define C1GSR_DOS_BIT 1
#define CAN1GSR_DOS_BIT C1GSR_DOS_BIT
#define C1GSR_TBS_MASK 0x4
#define CAN1GSR_TBS_MASK C1GSR_TBS_MASK
#define C1GSR_TBS 0x4
#define CAN1GSR_TBS C1GSR_TBS
#define C1GSR_TBS_BIT 2
#define CAN1GSR_TBS_BIT C1GSR_TBS_BIT
#define C1GSR_TCS_MASK 0x8
#define CAN1GSR_TCS_MASK C1GSR_TCS_MASK
#define C1GSR_TCS 0x8
#define CAN1GSR_TCS C1GSR_TCS
#define C1GSR_TCS_BIT 3
#define CAN1GSR_TCS_BIT C1GSR_TCS_BIT
#define C1GSR_RS_MASK 0x10
#define CAN1GSR_RS_MASK C1GSR_RS_MASK
#define C1GSR_RS 0x10
#define CAN1GSR_RS C1GSR_RS
#define C1GSR_RS_BIT 4
#define CAN1GSR_RS_BIT C1GSR_RS_BIT
#define C1GSR_TS_MASK 0x20
#define CAN1GSR_TS_MASK C1GSR_TS_MASK
#define C1GSR_TS 0x20
#define CAN1GSR_TS C1GSR_TS
#define C1GSR_TS_BIT 5
#define CAN1GSR_TS_BIT C1GSR_TS_BIT
#define C1GSR_ES_MASK 0x40
#define CAN1GSR_ES_MASK C1GSR_ES_MASK
#define C1GSR_ES 0x40
#define CAN1GSR_ES C1GSR_ES
#define C1GSR_ES_BIT 6
#define CAN1GSR_ES_BIT C1GSR_ES_BIT
#define C1GSR_BS_MASK 0x80
#define CAN1GSR_BS_MASK C1GSR_BS_MASK
#define C1GSR_BS 0x80
#define CAN1GSR_BS C1GSR_BS
#define C1GSR_BS_BIT 7
#define CAN1GSR_BS_BIT C1GSR_BS_BIT
#define C1GSR_RXERR_MASK 0xFF0000
#define CAN1GSR_RXERR_MASK C1GSR_RXERR_MASK
#define C1GSR_RXERR_BIT 16
#define CAN1GSR_RXERR_BIT C1GSR_RXERR_BIT
#define C1GSR_TXERR_MASK 0xFF000000
#define CAN1GSR_TXERR_MASK C1GSR_TXERR_MASK
#define C1GSR_TXERR_BIT 24
#define CAN1GSR_TXERR_BIT C1GSR_TXERR_BIT

#define C1ICR (*(volatile unsigned long *)0xE004400C)
#define CAN1ICR C1ICR
#define C1ICR_OFFSET 0xC
#define CAN1ICR_OFFSET C1ICR_OFFSET
#define C1ICR_RI_MASK 0x1
#define CAN1ICR_RI_MASK C1ICR_RI_MASK
#define C1ICR_RI 0x1
#define CAN1ICR_RI C1ICR_RI
#define C1ICR_RI_BIT 0
#define CAN1ICR_RI_BIT C1ICR_RI_BIT
#define C1ICR_TI1_MASK 0x2
#define CAN1ICR_TI1_MASK C1ICR_TI1_MASK
#define C1ICR_TI1 0x2
#define CAN1ICR_TI1 C1ICR_TI1
#define C1ICR_TI1_BIT 1
#define CAN1ICR_TI1_BIT C1ICR_TI1_BIT
#define C1ICR_EI_MASK 0x4
#define CAN1ICR_EI_MASK C1ICR_EI_MASK
#define C1ICR_EI 0x4
#define CAN1ICR_EI C1ICR_EI
#define C1ICR_EI_BIT 2
#define CAN1ICR_EI_BIT C1ICR_EI_BIT
#define C1ICR_DOI_MASK 0x8
#define CAN1ICR_DOI_MASK C1ICR_DOI_MASK
#define C1ICR_DOI 0x8
#define CAN1ICR_DOI C1ICR_DOI
#define C1ICR_DOI_BIT 3
#define CAN1ICR_DOI_BIT C1ICR_DOI_BIT
#define C1ICR_WUI_MASK 0x10
#define CAN1ICR_WUI_MASK C1ICR_WUI_MASK
#define C1ICR_WUI 0x10
#define CAN1ICR_WUI C1ICR_WUI
#define C1ICR_WUI_BIT 4
#define CAN1ICR_WUI_BIT C1ICR_WUI_BIT
#define C1ICR_EPI_MASK 0x20
#define CAN1ICR_EPI_MASK C1ICR_EPI_MASK
#define C1ICR_EPI 0x20
#define CAN1ICR_EPI C1ICR_EPI
#define C1ICR_EPI_BIT 5
#define CAN1ICR_EPI_BIT C1ICR_EPI_BIT
#define C1ICR_ALI_MASK 0x40
#define CAN1ICR_ALI_MASK C1ICR_ALI_MASK
#define C1ICR_ALI 0x40
#define CAN1ICR_ALI C1ICR_ALI
#define C1ICR_ALI_BIT 6
#define CAN1ICR_ALI_BIT C1ICR_ALI_BIT
#define C1ICR_BEI_MASK 0x80
#define CAN1ICR_BEI_MASK C1ICR_BEI_MASK
#define C1ICR_BEI 0x80
#define CAN1ICR_BEI C1ICR_BEI
#define C1ICR_BEI_BIT 7
#define CAN1ICR_BEI_BIT C1ICR_BEI_BIT
#define C1ICR_IDI_MASK 0x100
#define CAN1ICR_IDI_MASK C1ICR_IDI_MASK
#define C1ICR_IDI 0x100
#define CAN1ICR_IDI C1ICR_IDI
#define C1ICR_IDI_BIT 8
#define CAN1ICR_IDI_BIT C1ICR_IDI_BIT
#define C1ICR_TI2_MASK 0x200
#define CAN1ICR_TI2_MASK C1ICR_TI2_MASK
#define C1ICR_TI2 0x200
#define CAN1ICR_TI2 C1ICR_TI2
#define C1ICR_TI2_BIT 9
#define CAN1ICR_TI2_BIT C1ICR_TI2_BIT
#define C1ICR_TI3_MASK 0x400
#define CAN1ICR_TI3_MASK C1ICR_TI3_MASK
#define C1ICR_TI3 0x400
#define CAN1ICR_TI3 C1ICR_TI3
#define C1ICR_TI3_BIT 10
#define CAN1ICR_TI3_BIT C1ICR_TI3_BIT
#define C1ICR_ERRBIT_MASK 0x1F0000
#define CAN1ICR_ERRBIT_MASK C1ICR_ERRBIT_MASK
#define C1ICR_ERRBIT_BIT 16
#define CAN1ICR_ERRBIT_BIT C1ICR_ERRBIT_BIT
#define C1ICR_ERRDIR_MASK 0x200000
#define CAN1ICR_ERRDIR_MASK C1ICR_ERRDIR_MASK
#define C1ICR_ERRDIR 0x200000
#define CAN1ICR_ERRDIR C1ICR_ERRDIR
#define C1ICR_ERRDIR_BIT 21
#define CAN1ICR_ERRDIR_BIT C1ICR_ERRDIR_BIT
#define C1ICR_ERRC_MASK 0xC00000
#define CAN1ICR_ERRC_MASK C1ICR_ERRC_MASK
#define C1ICR_ERRC_BIT 22
#define CAN1ICR_ERRC_BIT C1ICR_ERRC_BIT
#define C1ICR_ALCBIT_MASK 0x1F000000
#define CAN1ICR_ALCBIT_MASK C1ICR_ALCBIT_MASK
#define C1ICR_ALCBIT_BIT 24
#define CAN1ICR_ALCBIT_BIT C1ICR_ALCBIT_BIT

#define C1IER (*(volatile unsigned long *)0xE0044010)
#define CAN1IER C1IER
#define C1IER_OFFSET 0x10
#define CAN1IER_OFFSET C1IER_OFFSET
#define C1IER_RIE_MASK 0x1
#define CAN1IER_RIE_MASK C1IER_RIE_MASK
#define C1IER_RIE 0x1
#define CAN1IER_RIE C1IER_RIE
#define C1IER_RIE_BIT 0
#define CAN1IER_RIE_BIT C1IER_RIE_BIT
#define C1IER_TIE1_MASK 0x2
#define CAN1IER_TIE1_MASK C1IER_TIE1_MASK
#define C1IER_TIE1 0x2
#define CAN1IER_TIE1 C1IER_TIE1
#define C1IER_TIE1_BIT 1
#define CAN1IER_TIE1_BIT C1IER_TIE1_BIT
#define C1IER_EIE_MASK 0x4
#define CAN1IER_EIE_MASK C1IER_EIE_MASK
#define C1IER_EIE 0x4
#define CAN1IER_EIE C1IER_EIE
#define C1IER_EIE_BIT 2
#define CAN1IER_EIE_BIT C1IER_EIE_BIT
#define C1IER_DOIE_MASK 0x8
#define CAN1IER_DOIE_MASK C1IER_DOIE_MASK
#define C1IER_DOIE 0x8
#define CAN1IER_DOIE C1IER_DOIE
#define C1IER_DOIE_BIT 3
#define CAN1IER_DOIE_BIT C1IER_DOIE_BIT
#define C1IER_WUIE_MASK 0x10
#define CAN1IER_WUIE_MASK C1IER_WUIE_MASK
#define C1IER_WUIE 0x10
#define CAN1IER_WUIE C1IER_WUIE
#define C1IER_WUIE_BIT 4
#define CAN1IER_WUIE_BIT C1IER_WUIE_BIT
#define C1IER_EPIE_MASK 0x20
#define CAN1IER_EPIE_MASK C1IER_EPIE_MASK
#define C1IER_EPIE 0x20
#define CAN1IER_EPIE C1IER_EPIE
#define C1IER_EPIE_BIT 5
#define CAN1IER_EPIE_BIT C1IER_EPIE_BIT
#define C1IER_ALIE_MASK 0x40
#define CAN1IER_ALIE_MASK C1IER_ALIE_MASK
#define C1IER_ALIE 0x40
#define CAN1IER_ALIE C1IER_ALIE
#define C1IER_ALIE_BIT 6
#define CAN1IER_ALIE_BIT C1IER_ALIE_BIT
#define C1IER_BEIE_MASK 0x80
#define CAN1IER_BEIE_MASK C1IER_BEIE_MASK
#define C1IER_BEIE 0x80
#define CAN1IER_BEIE C1IER_BEIE
#define C1IER_BEIE_BIT 7
#define CAN1IER_BEIE_BIT C1IER_BEIE_BIT
#define C1IER_IDIE_MASK 0x100
#define CAN1IER_IDIE_MASK C1IER_IDIE_MASK
#define C1IER_IDIE 0x100
#define CAN1IER_IDIE C1IER_IDIE
#define C1IER_IDIE_BIT 8
#define CAN1IER_IDIE_BIT C1IER_IDIE_BIT
#define C1IER_TIE2_MASK 0x200
#define CAN1IER_TIE2_MASK C1IER_TIE2_MASK
#define C1IER_TIE2 0x200
#define CAN1IER_TIE2 C1IER_TIE2
#define C1IER_TIE2_BIT 9
#define CAN1IER_TIE2_BIT C1IER_TIE2_BIT
#define C1IER_TIE3_MASK 0x400
#define CAN1IER_TIE3_MASK C1IER_TIE3_MASK
#define C1IER_TIE3 0x400
#define CAN1IER_TIE3 C1IER_TIE3
#define C1IER_TIE3_BIT 10
#define CAN1IER_TIE3_BIT C1IER_TIE3_BIT

#define C1BTR (*(volatile unsigned long *)0xE0044014)
#define CAN1BTR C1BTR
#define C1BTR_OFFSET 0x14
#define CAN1BTR_OFFSET C1BTR_OFFSET
#define C1BTR_BRP_MASK 0x3FF
#define CAN1BTR_BRP_MASK C1BTR_BRP_MASK
#define C1BTR_BRP_BIT 0
#define CAN1BTR_BRP_BIT C1BTR_BRP_BIT
#define C1BTR_SJW_MASK 0xC000
#define CAN1BTR_SJW_MASK C1BTR_SJW_MASK
#define C1BTR_SJW_BIT 14
#define CAN1BTR_SJW_BIT C1BTR_SJW_BIT
#define C1BTR_TSEG1_MASK 0xF0000
#define CAN1BTR_TSEG1_MASK C1BTR_TSEG1_MASK
#define C1BTR_TSEG1_BIT 16
#define CAN1BTR_TSEG1_BIT C1BTR_TSEG1_BIT
#define C1BTR_TSEG2_MASK 0x700000
#define CAN1BTR_TSEG2_MASK C1BTR_TSEG2_MASK
#define C1BTR_TSEG2_BIT 20
#define CAN1BTR_TSEG2_BIT C1BTR_TSEG2_BIT
#define C1BTR_SAM_MASK 0x800000
#define CAN1BTR_SAM_MASK C1BTR_SAM_MASK
#define C1BTR_SAM 0x800000
#define CAN1BTR_SAM C1BTR_SAM
#define C1BTR_SAM_BIT 23
#define CAN1BTR_SAM_BIT C1BTR_SAM_BIT

#define C1EWL (*(volatile unsigned long *)0xE0044018)
#define CAN1EWL C1EWL
#define C1EWL_OFFSET 0x18
#define CAN1EWL_OFFSET C1EWL_OFFSET
#define C1EWL_EWL_MASK 0xFF
#define CAN1EWL_EWL_MASK C1EWL_EWL_MASK
#define C1EWL_EWL_BIT 0
#define CAN1EWL_EWL_BIT C1EWL_EWL_BIT

#define C1SR (*(volatile unsigned long *)0xE004401C)
#define CAN1SR C1SR
#define C1SR_OFFSET 0x1C
#define CAN1SR_OFFSET C1SR_OFFSET
#define C1SR_RBS_MASK 0x1
#define CAN1SR_RBS_MASK C1SR_RBS_MASK
#define C1SR_RBS 0x1
#define CAN1SR_RBS C1SR_RBS
#define C1SR_RBS_BIT 0
#define CAN1SR_RBS_BIT C1SR_RBS_BIT
#define C1SR_DOS_MASK 0x2
#define CAN1SR_DOS_MASK C1SR_DOS_MASK
#define C1SR_DOS 0x2
#define CAN1SR_DOS C1SR_DOS
#define C1SR_DOS_BIT 1
#define CAN1SR_DOS_BIT C1SR_DOS_BIT
#define C1SR_TBS1_MASK 0x4
#define CAN1SR_TBS1_MASK C1SR_TBS1_MASK
#define C1SR_TBS1 0x4
#define CAN1SR_TBS1 C1SR_TBS1
#define C1SR_TBS1_BIT 2
#define CAN1SR_TBS1_BIT C1SR_TBS1_BIT
#define C1SR_TCS1_MASK 0x8
#define CAN1SR_TCS1_MASK C1SR_TCS1_MASK
#define C1SR_TCS1 0x8
#define CAN1SR_TCS1 C1SR_TCS1
#define C1SR_TCS1_BIT 3
#define CAN1SR_TCS1_BIT C1SR_TCS1_BIT
#define C1SR_RS_MASK 0x10
#define CAN1SR_RS_MASK C1SR_RS_MASK
#define C1SR_RS 0x10
#define CAN1SR_RS C1SR_RS
#define C1SR_RS_BIT 4
#define CAN1SR_RS_BIT C1SR_RS_BIT
#define C1SR_TS1_MASK 0x20
#define CAN1SR_TS1_MASK C1SR_TS1_MASK
#define C1SR_TS1 0x20
#define CAN1SR_TS1 C1SR_TS1
#define C1SR_TS1_BIT 5
#define CAN1SR_TS1_BIT C1SR_TS1_BIT
#define C1SR_ES_MASK 0x40
#define CAN1SR_ES_MASK C1SR_ES_MASK
#define C1SR_ES 0x40
#define CAN1SR_ES C1SR_ES
#define C1SR_ES_BIT 6
#define CAN1SR_ES_BIT C1SR_ES_BIT
#define C1SR_BS_MASK 0x80
#define CAN1SR_BS_MASK C1SR_BS_MASK
#define C1SR_BS 0x80
#define CAN1SR_BS C1SR_BS
#define C1SR_BS_BIT 7
#define CAN1SR_BS_BIT C1SR_BS_BIT
#define C1SR_RBS2_MASK 0x100
#define CAN1SR_RBS2_MASK C1SR_RBS2_MASK
#define C1SR_RBS2 0x100
#define CAN1SR_RBS2 C1SR_RBS2
#define C1SR_RBS2_BIT 8
#define CAN1SR_RBS2_BIT C1SR_RBS2_BIT
#define C1SR_DOS2_MASK 0x200
#define CAN1SR_DOS2_MASK C1SR_DOS2_MASK
#define C1SR_DOS2 0x200
#define CAN1SR_DOS2 C1SR_DOS2
#define C1SR_DOS2_BIT 9
#define CAN1SR_DOS2_BIT C1SR_DOS2_BIT
#define C1SR_TBS2_MASK 0x400
#define CAN1SR_TBS2_MASK C1SR_TBS2_MASK
#define C1SR_TBS2 0x400
#define CAN1SR_TBS2 C1SR_TBS2
#define C1SR_TBS2_BIT 10
#define CAN1SR_TBS2_BIT C1SR_TBS2_BIT
#define C1SR_TCS2_MASK 0x800
#define CAN1SR_TCS2_MASK C1SR_TCS2_MASK
#define C1SR_TCS2 0x800
#define CAN1SR_TCS2 C1SR_TCS2
#define C1SR_TCS2_BIT 11
#define CAN1SR_TCS2_BIT C1SR_TCS2_BIT
#define C1SR_RS2_MASK 0x1000
#define CAN1SR_RS2_MASK C1SR_RS2_MASK
#define C1SR_RS2 0x1000
#define CAN1SR_RS2 C1SR_RS2
#define C1SR_RS2_BIT 12
#define CAN1SR_RS2_BIT C1SR_RS2_BIT
#define C1SR_TS2_MASK 0x2000
#define CAN1SR_TS2_MASK C1SR_TS2_MASK
#define C1SR_TS2 0x2000
#define CAN1SR_TS2 C1SR_TS2
#define C1SR_TS2_BIT 13
#define CAN1SR_TS2_BIT C1SR_TS2_BIT
#define C1SR_ES2_MASK 0x4000
#define CAN1SR_ES2_MASK C1SR_ES2_MASK
#define C1SR_ES2 0x4000
#define CAN1SR_ES2 C1SR_ES2
#define C1SR_ES2_BIT 14
#define CAN1SR_ES2_BIT C1SR_ES2_BIT
#define C1SR_BS2_MASK 0x8000
#define CAN1SR_BS2_MASK C1SR_BS2_MASK
#define C1SR_BS2 0x8000
#define CAN1SR_BS2 C1SR_BS2
#define C1SR_BS2_BIT 15
#define CAN1SR_BS2_BIT C1SR_BS2_BIT
#define C1SR_RBS3_MASK 0x10000
#define CAN1SR_RBS3_MASK C1SR_RBS3_MASK
#define C1SR_RBS3 0x10000
#define CAN1SR_RBS3 C1SR_RBS3
#define C1SR_RBS3_BIT 16
#define CAN1SR_RBS3_BIT C1SR_RBS3_BIT
#define C1SR_DOS3_MASK 0x20000
#define CAN1SR_DOS3_MASK C1SR_DOS3_MASK
#define C1SR_DOS3 0x20000
#define CAN1SR_DOS3 C1SR_DOS3
#define C1SR_DOS3_BIT 17
#define CAN1SR_DOS3_BIT C1SR_DOS3_BIT
#define C1SR_TBS3_MASK 0x40000
#define CAN1SR_TBS3_MASK C1SR_TBS3_MASK
#define C1SR_TBS3 0x40000
#define CAN1SR_TBS3 C1SR_TBS3
#define C1SR_TBS3_BIT 18
#define CAN1SR_TBS3_BIT C1SR_TBS3_BIT
#define C1SR_TCS3_MASK 0x80000
#define CAN1SR_TCS3_MASK C1SR_TCS3_MASK
#define C1SR_TCS3 0x80000
#define CAN1SR_TCS3 C1SR_TCS3
#define C1SR_TCS3_BIT 19
#define CAN1SR_TCS3_BIT C1SR_TCS3_BIT
#define C1SR_RS3_MASK 0x100000
#define CAN1SR_RS3_MASK C1SR_RS3_MASK
#define C1SR_RS3 0x100000
#define CAN1SR_RS3 C1SR_RS3
#define C1SR_RS3_BIT 20
#define CAN1SR_RS3_BIT C1SR_RS3_BIT
#define C1SR_TS3_MASK 0x200000
#define CAN1SR_TS3_MASK C1SR_TS3_MASK
#define C1SR_TS3 0x200000
#define CAN1SR_TS3 C1SR_TS3
#define C1SR_TS3_BIT 21
#define CAN1SR_TS3_BIT C1SR_TS3_BIT
#define C1SR_ES3_MASK 0x400000
#define CAN1SR_ES3_MASK C1SR_ES3_MASK
#define C1SR_ES3 0x400000
#define CAN1SR_ES3 C1SR_ES3
#define C1SR_ES3_BIT 22
#define CAN1SR_ES3_BIT C1SR_ES3_BIT
#define C1SR_BS3_MASK 0x800000
#define CAN1SR_BS3_MASK C1SR_BS3_MASK
#define C1SR_BS3 0x800000
#define CAN1SR_BS3 C1SR_BS3
#define C1SR_BS3_BIT 23
#define CAN1SR_BS3_BIT C1SR_BS3_BIT

#define C1RFS (*(volatile unsigned long *)0xE0044020)
#define CAN1RFS C1RFS
#define C1RFS_OFFSET 0x20
#define CAN1RFS_OFFSET C1RFS_OFFSET
#define C1RFS_ID_Index_MASK 0x3FF
#define CAN1RFS_ID_Index_MASK C1RFS_ID_Index_MASK
#define C1RFS_ID_Index_BIT 0
#define CAN1RFS_ID_Index_BIT C1RFS_ID_Index_BIT
#define C1RFS_BP_MASK 0x400
#define CAN1RFS_BP_MASK C1RFS_BP_MASK
#define C1RFS_BP 0x400
#define CAN1RFS_BP C1RFS_BP
#define C1RFS_BP_BIT 10
#define CAN1RFS_BP_BIT C1RFS_BP_BIT
#define C1RFS_DLC_MASK 0xF0000
#define CAN1RFS_DLC_MASK C1RFS_DLC_MASK
#define C1RFS_DLC_BIT 16
#define CAN1RFS_DLC_BIT C1RFS_DLC_BIT
#define C1RFS_RTR_MASK 0x40000000
#define CAN1RFS_RTR_MASK C1RFS_RTR_MASK
#define C1RFS_RTR 0x40000000
#define CAN1RFS_RTR C1RFS_RTR
#define C1RFS_RTR_BIT 30
#define CAN1RFS_RTR_BIT C1RFS_RTR_BIT
#define C1RFS_FF_MASK 0x80000000
#define CAN1RFS_FF_MASK C1RFS_FF_MASK
#define C1RFS_FF 0x80000000
#define CAN1RFS_FF C1RFS_FF
#define C1RFS_FF_BIT 31
#define CAN1RFS_FF_BIT C1RFS_FF_BIT

#define C1RID (*(volatile unsigned long *)0xE0044024)
#define CAN1RID C1RID
#define C1RID_OFFSET 0x24
#define CAN1RID_OFFSET C1RID_OFFSET
#define C1RID_ID_MASK 0x7FF
#define CAN1RID_ID_MASK C1RID_ID_MASK
#define C1RID_ID_BIT 0
#define CAN1RID_ID_BIT C1RID_ID_BIT

#define C1RDA (*(volatile unsigned long *)0xE0044028)
#define CAN1RDA C1RDA
#define C1RDA_OFFSET 0x28
#define CAN1RDA_OFFSET C1RDA_OFFSET
#define C1RDA_Data_1_MASK 0xFF
#define CAN1RDA_Data_1_MASK C1RDA_Data_1_MASK
#define C1RDA_Data_1_BIT 0
#define CAN1RDA_Data_1_BIT C1RDA_Data_1_BIT
#define C1RDA_Data_2_MASK 0xFF00
#define CAN1RDA_Data_2_MASK C1RDA_Data_2_MASK
#define C1RDA_Data_2_BIT 8
#define CAN1RDA_Data_2_BIT C1RDA_Data_2_BIT
#define C1RDA_Data_3_MASK 0xFF0000
#define CAN1RDA_Data_3_MASK C1RDA_Data_3_MASK
#define C1RDA_Data_3_BIT 16
#define CAN1RDA_Data_3_BIT C1RDA_Data_3_BIT
#define C1RDA_Data_4_MASK 0xFF000000
#define CAN1RDA_Data_4_MASK C1RDA_Data_4_MASK
#define C1RDA_Data_4_BIT 24
#define CAN1RDA_Data_4_BIT C1RDA_Data_4_BIT

#define C1RDB (*(volatile unsigned long *)0xE004402C)
#define CAN1RDB C1RDB
#define C1RDB_OFFSET 0x2C
#define CAN1RDB_OFFSET C1RDB_OFFSET
#define C1RDB_Data_5_MASK 0xFF
#define CAN1RDB_Data_5_MASK C1RDB_Data_5_MASK
#define C1RDB_Data_5_BIT 0
#define CAN1RDB_Data_5_BIT C1RDB_Data_5_BIT
#define C1RDB_Data_6_MASK 0xFF00
#define CAN1RDB_Data_6_MASK C1RDB_Data_6_MASK
#define C1RDB_Data_6_BIT 8
#define CAN1RDB_Data_6_BIT C1RDB_Data_6_BIT
#define C1RDB_Data_7_MASK 0xFF0000
#define CAN1RDB_Data_7_MASK C1RDB_Data_7_MASK
#define C1RDB_Data_7_BIT 16
#define CAN1RDB_Data_7_BIT C1RDB_Data_7_BIT
#define C1RDB_Data_8_MASK 0xFF000000
#define CAN1RDB_Data_8_MASK C1RDB_Data_8_MASK
#define C1RDB_Data_8_BIT 24
#define CAN1RDB_Data_8_BIT C1RDB_Data_8_BIT

#define C1TFI1 (*(volatile unsigned long *)0xE0044030)
#define CAN1TFI1 C1TFI1
#define C1TFI1_OFFSET 0x30
#define CAN1TFI1_OFFSET C1TFI1_OFFSET
#define C1TFI1_PRIO_MASK 0xFF
#define CAN1TFI1_PRIO_MASK C1TFI1_PRIO_MASK
#define C1TFI1_PRIO_BIT 0
#define CAN1TFI1_PRIO_BIT C1TFI1_PRIO_BIT
#define C1TFI1_DLC_MASK 0xF0000
#define CAN1TFI1_DLC_MASK C1TFI1_DLC_MASK
#define C1TFI1_DLC_BIT 16
#define CAN1TFI1_DLC_BIT C1TFI1_DLC_BIT
#define C1TFI1_RTR_MASK 0x40000000
#define CAN1TFI1_RTR_MASK C1TFI1_RTR_MASK
#define C1TFI1_RTR 0x40000000
#define CAN1TFI1_RTR C1TFI1_RTR
#define C1TFI1_RTR_BIT 30
#define CAN1TFI1_RTR_BIT C1TFI1_RTR_BIT
#define C1TFI1_FF_MASK 0x80000000
#define CAN1TFI1_FF_MASK C1TFI1_FF_MASK
#define C1TFI1_FF 0x80000000
#define CAN1TFI1_FF C1TFI1_FF
#define C1TFI1_FF_BIT 31
#define CAN1TFI1_FF_BIT C1TFI1_FF_BIT

#define C1TID1 (*(volatile unsigned long *)0xE0044034)
#define CAN1TID1 C1TID1
#define C1TID1_OFFSET 0x34
#define CAN1TID1_OFFSET C1TID1_OFFSET
#define C1TID1_ID_MASK 0x7FF
#define CAN1TID1_ID_MASK C1TID1_ID_MASK
#define C1TID1_ID_BIT 0
#define CAN1TID1_ID_BIT C1TID1_ID_BIT

#define C1TDA1 (*(volatile unsigned long *)0xE0044038)
#define CAN1TDA1 C1TDA1
#define C1TDA1_OFFSET 0x38
#define CAN1TDA1_OFFSET C1TDA1_OFFSET
#define C1TDA1_Data_1_MASK 0xFF
#define CAN1TDA1_Data_1_MASK C1TDA1_Data_1_MASK
#define C1TDA1_Data_1_BIT 0
#define CAN1TDA1_Data_1_BIT C1TDA1_Data_1_BIT
#define C1TDA1_Data_2_MASK 0xFF00
#define CAN1TDA1_Data_2_MASK C1TDA1_Data_2_MASK
#define C1TDA1_Data_2_BIT 8
#define CAN1TDA1_Data_2_BIT C1TDA1_Data_2_BIT
#define C1TDA1_Data_3_MASK 0xFF0000
#define CAN1TDA1_Data_3_MASK C1TDA1_Data_3_MASK
#define C1TDA1_Data_3_BIT 16
#define CAN1TDA1_Data_3_BIT C1TDA1_Data_3_BIT
#define C1TDA1_Data_4_MASK 0xFF000000
#define CAN1TDA1_Data_4_MASK C1TDA1_Data_4_MASK
#define C1TDA1_Data_4_BIT 24
#define CAN1TDA1_Data_4_BIT C1TDA1_Data_4_BIT

#define C1TDB1 (*(volatile unsigned long *)0xE004403C)
#define CAN1TDB1 C1TDB1
#define C1TDB1_OFFSET 0x3C
#define CAN1TDB1_OFFSET C1TDB1_OFFSET
#define C1TDB1_Data_5_MASK 0xFF
#define CAN1TDB1_Data_5_MASK C1TDB1_Data_5_MASK
#define C1TDB1_Data_5_BIT 0
#define CAN1TDB1_Data_5_BIT C1TDB1_Data_5_BIT
#define C1TDB1_Data_6_MASK 0xFF00
#define CAN1TDB1_Data_6_MASK C1TDB1_Data_6_MASK
#define C1TDB1_Data_6_BIT 8
#define CAN1TDB1_Data_6_BIT C1TDB1_Data_6_BIT
#define C1TDB1_Data_7_MASK 0xFF0000
#define CAN1TDB1_Data_7_MASK C1TDB1_Data_7_MASK
#define C1TDB1_Data_7_BIT 16
#define CAN1TDB1_Data_7_BIT C1TDB1_Data_7_BIT
#define C1TDB1_Data_8_MASK 0xFF000000
#define CAN1TDB1_Data_8_MASK C1TDB1_Data_8_MASK
#define C1TDB1_Data_8_BIT 24
#define CAN1TDB1_Data_8_BIT C1TDB1_Data_8_BIT

#define C1TFI2 (*(volatile unsigned long *)0xE0044040)
#define CAN1TFI2 C1TFI2
#define C1TFI2_OFFSET 0x40
#define CAN1TFI2_OFFSET C1TFI2_OFFSET
#define C1TFI2_PRIO_MASK 0xFF
#define CAN1TFI2_PRIO_MASK C1TFI2_PRIO_MASK
#define C1TFI2_PRIO_BIT 0
#define CAN1TFI2_PRIO_BIT C1TFI2_PRIO_BIT
#define C1TFI2_DLC_MASK 0xF0000
#define CAN1TFI2_DLC_MASK C1TFI2_DLC_MASK
#define C1TFI2_DLC_BIT 16
#define CAN1TFI2_DLC_BIT C1TFI2_DLC_BIT
#define C1TFI2_RTR_MASK 0x40000000
#define CAN1TFI2_RTR_MASK C1TFI2_RTR_MASK
#define C1TFI2_RTR 0x40000000
#define CAN1TFI2_RTR C1TFI2_RTR
#define C1TFI2_RTR_BIT 30
#define CAN1TFI2_RTR_BIT C1TFI2_RTR_BIT
#define C1TFI2_FF_MASK 0x80000000
#define CAN1TFI2_FF_MASK C1TFI2_FF_MASK
#define C1TFI2_FF 0x80000000
#define CAN1TFI2_FF C1TFI2_FF
#define C1TFI2_FF_BIT 31
#define CAN1TFI2_FF_BIT C1TFI2_FF_BIT

#define C1TID2 (*(volatile unsigned long *)0xE0044044)
#define CAN1TID2 C1TID2
#define C1TID2_OFFSET 0x44
#define CAN1TID2_OFFSET C1TID2_OFFSET
#define C1TID2_ID_MASK 0x7FF
#define CAN1TID2_ID_MASK C1TID2_ID_MASK
#define C1TID2_ID_BIT 0
#define CAN1TID2_ID_BIT C1TID2_ID_BIT

#define C1TDA2 (*(volatile unsigned long *)0xE0044048)
#define CAN1TDA2 C1TDA2
#define C1TDA2_OFFSET 0x48
#define CAN1TDA2_OFFSET C1TDA2_OFFSET
#define C1TDA2_Data_1_MASK 0xFF
#define CAN1TDA2_Data_1_MASK C1TDA2_Data_1_MASK
#define C1TDA2_Data_1_BIT 0
#define CAN1TDA2_Data_1_BIT C1TDA2_Data_1_BIT
#define C1TDA2_Data_2_MASK 0xFF00
#define CAN1TDA2_Data_2_MASK C1TDA2_Data_2_MASK
#define C1TDA2_Data_2_BIT 8
#define CAN1TDA2_Data_2_BIT C1TDA2_Data_2_BIT
#define C1TDA2_Data_3_MASK 0xFF0000
#define CAN1TDA2_Data_3_MASK C1TDA2_Data_3_MASK
#define C1TDA2_Data_3_BIT 16
#define CAN1TDA2_Data_3_BIT C1TDA2_Data_3_BIT
#define C1TDA2_Data_4_MASK 0xFF000000
#define CAN1TDA2_Data_4_MASK C1TDA2_Data_4_MASK
#define C1TDA2_Data_4_BIT 24
#define CAN1TDA2_Data_4_BIT C1TDA2_Data_4_BIT

#define C1TDB2 (*(volatile unsigned long *)0xE004404C)
#define CAN1TDB2 C1TDB2
#define C1TDB2_OFFSET 0x4C
#define CAN1TDB2_OFFSET C1TDB2_OFFSET
#define C1TDB2_Data_5_MASK 0xFF
#define CAN1TDB2_Data_5_MASK C1TDB2_Data_5_MASK
#define C1TDB2_Data_5_BIT 0
#define CAN1TDB2_Data_5_BIT C1TDB2_Data_5_BIT
#define C1TDB2_Data_6_MASK 0xFF00
#define CAN1TDB2_Data_6_MASK C1TDB2_Data_6_MASK
#define C1TDB2_Data_6_BIT 8
#define CAN1TDB2_Data_6_BIT C1TDB2_Data_6_BIT
#define C1TDB2_Data_7_MASK 0xFF0000
#define CAN1TDB2_Data_7_MASK C1TDB2_Data_7_MASK
#define C1TDB2_Data_7_BIT 16
#define CAN1TDB2_Data_7_BIT C1TDB2_Data_7_BIT
#define C1TDB2_Data_8_MASK 0xFF000000
#define CAN1TDB2_Data_8_MASK C1TDB2_Data_8_MASK
#define C1TDB2_Data_8_BIT 24
#define CAN1TDB2_Data_8_BIT C1TDB2_Data_8_BIT

#define C1TFI3 (*(volatile unsigned long *)0xE0044050)
#define CAN1TFI3 C1TFI3
#define C1TFI3_OFFSET 0x50
#define CAN1TFI3_OFFSET C1TFI3_OFFSET
#define C1TFI3_PRIO_MASK 0xFF
#define CAN1TFI3_PRIO_MASK C1TFI3_PRIO_MASK
#define C1TFI3_PRIO_BIT 0
#define CAN1TFI3_PRIO_BIT C1TFI3_PRIO_BIT
#define C1TFI3_DLC_MASK 0xF0000
#define CAN1TFI3_DLC_MASK C1TFI3_DLC_MASK
#define C1TFI3_DLC_BIT 16
#define CAN1TFI3_DLC_BIT C1TFI3_DLC_BIT
#define C1TFI3_RTR_MASK 0x40000000
#define CAN1TFI3_RTR_MASK C1TFI3_RTR_MASK
#define C1TFI3_RTR 0x40000000
#define CAN1TFI3_RTR C1TFI3_RTR
#define C1TFI3_RTR_BIT 30
#define CAN1TFI3_RTR_BIT C1TFI3_RTR_BIT
#define C1TFI3_FF_MASK 0x80000000
#define CAN1TFI3_FF_MASK C1TFI3_FF_MASK
#define C1TFI3_FF 0x80000000
#define CAN1TFI3_FF C1TFI3_FF
#define C1TFI3_FF_BIT 31
#define CAN1TFI3_FF_BIT C1TFI3_FF_BIT

#define C1TID3 (*(volatile unsigned long *)0xE0044054)
#define CAN1TID3 C1TID3
#define C1TID3_OFFSET 0x54
#define CAN1TID3_OFFSET C1TID3_OFFSET
#define C1TID3_ID_MASK 0x7FF
#define CAN1TID3_ID_MASK C1TID3_ID_MASK
#define C1TID3_ID_BIT 0
#define CAN1TID3_ID_BIT C1TID3_ID_BIT

#define C1TDA3 (*(volatile unsigned long *)0xE0044058)
#define CAN1TDA3 C1TDA3
#define C1TDA3_OFFSET 0x58
#define CAN1TDA3_OFFSET C1TDA3_OFFSET
#define C1TDA3_Data_1_MASK 0xFF
#define CAN1TDA3_Data_1_MASK C1TDA3_Data_1_MASK
#define C1TDA3_Data_1_BIT 0
#define CAN1TDA3_Data_1_BIT C1TDA3_Data_1_BIT
#define C1TDA3_Data_2_MASK 0xFF00
#define CAN1TDA3_Data_2_MASK C1TDA3_Data_2_MASK
#define C1TDA3_Data_2_BIT 8
#define CAN1TDA3_Data_2_BIT C1TDA3_Data_2_BIT
#define C1TDA3_Data_3_MASK 0xFF0000
#define CAN1TDA3_Data_3_MASK C1TDA3_Data_3_MASK
#define C1TDA3_Data_3_BIT 16
#define CAN1TDA3_Data_3_BIT C1TDA3_Data_3_BIT
#define C1TDA3_Data_4_MASK 0xFF000000
#define CAN1TDA3_Data_4_MASK C1TDA3_Data_4_MASK
#define C1TDA3_Data_4_BIT 24
#define CAN1TDA3_Data_4_BIT C1TDA3_Data_4_BIT

#define C1TDB3 (*(volatile unsigned long *)0xE004405C)
#define CAN1TDB3 C1TDB3
#define C1TDB3_OFFSET 0x5C
#define CAN1TDB3_OFFSET C1TDB3_OFFSET
#define C1TDB3_Data_5_MASK 0xFF
#define CAN1TDB3_Data_5_MASK C1TDB3_Data_5_MASK
#define C1TDB3_Data_5_BIT 0
#define CAN1TDB3_Data_5_BIT C1TDB3_Data_5_BIT
#define C1TDB3_Data_6_MASK 0xFF00
#define CAN1TDB3_Data_6_MASK C1TDB3_Data_6_MASK
#define C1TDB3_Data_6_BIT 8
#define CAN1TDB3_Data_6_BIT C1TDB3_Data_6_BIT
#define C1TDB3_Data_7_MASK 0xFF0000
#define CAN1TDB3_Data_7_MASK C1TDB3_Data_7_MASK
#define C1TDB3_Data_7_BIT 16
#define CAN1TDB3_Data_7_BIT C1TDB3_Data_7_BIT
#define C1TDB3_Data_8_MASK 0xFF000000
#define CAN1TDB3_Data_8_MASK C1TDB3_Data_8_MASK
#define C1TDB3_Data_8_BIT 24
#define CAN1TDB3_Data_8_BIT C1TDB3_Data_8_BIT

#define CAN2_BASE 0xE0048000

#define C2MOD (*(volatile unsigned long *)0xE0048000)
#define CAN2MOD C2MOD
#define C2MOD_OFFSET 0x0
#define CAN2MOD_OFFSET C2MOD_OFFSET
#define C2MOD_RM_MASK 0x1
#define CAN2MOD_RM_MASK C2MOD_RM_MASK
#define C2MOD_RM 0x1
#define CAN2MOD_RM C2MOD_RM
#define C2MOD_RM_BIT 0
#define CAN2MOD_RM_BIT C2MOD_RM_BIT
#define C2MOD_LOM_MASK 0x2
#define CAN2MOD_LOM_MASK C2MOD_LOM_MASK
#define C2MOD_LOM 0x2
#define CAN2MOD_LOM C2MOD_LOM
#define C2MOD_LOM_BIT 1
#define CAN2MOD_LOM_BIT C2MOD_LOM_BIT
#define C2MOD_STM_MASK 0x4
#define CAN2MOD_STM_MASK C2MOD_STM_MASK
#define C2MOD_STM 0x4
#define CAN2MOD_STM C2MOD_STM
#define C2MOD_STM_BIT 2
#define CAN2MOD_STM_BIT C2MOD_STM_BIT
#define C2MOD_TPM_MASK 0x8
#define CAN2MOD_TPM_MASK C2MOD_TPM_MASK
#define C2MOD_TPM 0x8
#define CAN2MOD_TPM C2MOD_TPM
#define C2MOD_TPM_BIT 3
#define CAN2MOD_TPM_BIT C2MOD_TPM_BIT
#define C2MOD_SM_MASK 0x10
#define CAN2MOD_SM_MASK C2MOD_SM_MASK
#define C2MOD_SM 0x10
#define CAN2MOD_SM C2MOD_SM
#define C2MOD_SM_BIT 4
#define CAN2MOD_SM_BIT C2MOD_SM_BIT
#define C2MOD_RPM_MASK 0x20
#define CAN2MOD_RPM_MASK C2MOD_RPM_MASK
#define C2MOD_RPM 0x20
#define CAN2MOD_RPM C2MOD_RPM
#define C2MOD_RPM_BIT 5
#define CAN2MOD_RPM_BIT C2MOD_RPM_BIT
#define C2MOD_TM_MASK 0x80
#define CAN2MOD_TM_MASK C2MOD_TM_MASK
#define C2MOD_TM 0x80
#define CAN2MOD_TM C2MOD_TM
#define C2MOD_TM_BIT 7
#define CAN2MOD_TM_BIT C2MOD_TM_BIT

#define C2CMR (*(volatile unsigned long *)0xE0048004)
#define CAN2CMR C2CMR
#define C2CMR_OFFSET 0x4
#define CAN2CMR_OFFSET C2CMR_OFFSET
#define C2CMR_TR_MASK 0x1
#define CAN2CMR_TR_MASK C2CMR_TR_MASK
#define C2CMR_TR 0x1
#define CAN2CMR_TR C2CMR_TR
#define C2CMR_TR_BIT 0
#define CAN2CMR_TR_BIT C2CMR_TR_BIT
#define C2CMR_AT_MASK 0x2
#define CAN2CMR_AT_MASK C2CMR_AT_MASK
#define C2CMR_AT 0x2
#define CAN2CMR_AT C2CMR_AT
#define C2CMR_AT_BIT 1
#define CAN2CMR_AT_BIT C2CMR_AT_BIT
#define C2CMR_RRB_MASK 0x4
#define CAN2CMR_RRB_MASK C2CMR_RRB_MASK
#define C2CMR_RRB 0x4
#define CAN2CMR_RRB C2CMR_RRB
#define C2CMR_RRB_BIT 2
#define CAN2CMR_RRB_BIT C2CMR_RRB_BIT
#define C2CMR_CDO_MASK 0x8
#define CAN2CMR_CDO_MASK C2CMR_CDO_MASK
#define C2CMR_CDO 0x8
#define CAN2CMR_CDO C2CMR_CDO
#define C2CMR_CDO_BIT 3
#define CAN2CMR_CDO_BIT C2CMR_CDO_BIT
#define C2CMR_SRR_MASK 0x10
#define CAN2CMR_SRR_MASK C2CMR_SRR_MASK
#define C2CMR_SRR 0x10
#define CAN2CMR_SRR C2CMR_SRR
#define C2CMR_SRR_BIT 4
#define CAN2CMR_SRR_BIT C2CMR_SRR_BIT
#define C2CMR_STB1_MASK 0x20
#define CAN2CMR_STB1_MASK C2CMR_STB1_MASK
#define C2CMR_STB1 0x20
#define CAN2CMR_STB1 C2CMR_STB1
#define C2CMR_STB1_BIT 5
#define CAN2CMR_STB1_BIT C2CMR_STB1_BIT
#define C2CMR_STB2_MASK 0x40
#define CAN2CMR_STB2_MASK C2CMR_STB2_MASK
#define C2CMR_STB2 0x40
#define CAN2CMR_STB2 C2CMR_STB2
#define C2CMR_STB2_BIT 6
#define CAN2CMR_STB2_BIT C2CMR_STB2_BIT
#define C2CMR_STB3_MASK 0x80
#define CAN2CMR_STB3_MASK C2CMR_STB3_MASK
#define C2CMR_STB3 0x80
#define CAN2CMR_STB3 C2CMR_STB3
#define C2CMR_STB3_BIT 7
#define CAN2CMR_STB3_BIT C2CMR_STB3_BIT

#define C2GSR (*(volatile unsigned long *)0xE0048008)
#define CAN2GSR C2GSR
#define C2GSR_OFFSET 0x8
#define CAN2GSR_OFFSET C2GSR_OFFSET
#define C2GSR_RBS_MASK 0x1
#define CAN2GSR_RBS_MASK C2GSR_RBS_MASK
#define C2GSR_RBS 0x1
#define CAN2GSR_RBS C2GSR_RBS
#define C2GSR_RBS_BIT 0
#define CAN2GSR_RBS_BIT C2GSR_RBS_BIT
#define C2GSR_DOS_MASK 0x2
#define CAN2GSR_DOS_MASK C2GSR_DOS_MASK
#define C2GSR_DOS 0x2
#define CAN2GSR_DOS C2GSR_DOS
#define C2GSR_DOS_BIT 1
#define CAN2GSR_DOS_BIT C2GSR_DOS_BIT
#define C2GSR_TBS_MASK 0x4
#define CAN2GSR_TBS_MASK C2GSR_TBS_MASK
#define C2GSR_TBS 0x4
#define CAN2GSR_TBS C2GSR_TBS
#define C2GSR_TBS_BIT 2
#define CAN2GSR_TBS_BIT C2GSR_TBS_BIT
#define C2GSR_TCS_MASK 0x8
#define CAN2GSR_TCS_MASK C2GSR_TCS_MASK
#define C2GSR_TCS 0x8
#define CAN2GSR_TCS C2GSR_TCS
#define C2GSR_TCS_BIT 3
#define CAN2GSR_TCS_BIT C2GSR_TCS_BIT
#define C2GSR_RS_MASK 0x10
#define CAN2GSR_RS_MASK C2GSR_RS_MASK
#define C2GSR_RS 0x10
#define CAN2GSR_RS C2GSR_RS
#define C2GSR_RS_BIT 4
#define CAN2GSR_RS_BIT C2GSR_RS_BIT
#define C2GSR_TS_MASK 0x20
#define CAN2GSR_TS_MASK C2GSR_TS_MASK
#define C2GSR_TS 0x20
#define CAN2GSR_TS C2GSR_TS
#define C2GSR_TS_BIT 5
#define CAN2GSR_TS_BIT C2GSR_TS_BIT
#define C2GSR_ES_MASK 0x40
#define CAN2GSR_ES_MASK C2GSR_ES_MASK
#define C2GSR_ES 0x40
#define CAN2GSR_ES C2GSR_ES
#define C2GSR_ES_BIT 6
#define CAN2GSR_ES_BIT C2GSR_ES_BIT
#define C2GSR_BS_MASK 0x80
#define CAN2GSR_BS_MASK C2GSR_BS_MASK
#define C2GSR_BS 0x80
#define CAN2GSR_BS C2GSR_BS
#define C2GSR_BS_BIT 7
#define CAN2GSR_BS_BIT C2GSR_BS_BIT
#define C2GSR_RXERR_MASK 0xFF0000
#define CAN2GSR_RXERR_MASK C2GSR_RXERR_MASK
#define C2GSR_RXERR_BIT 16
#define CAN2GSR_RXERR_BIT C2GSR_RXERR_BIT
#define C2GSR_TXERR_MASK 0xFF000000
#define CAN2GSR_TXERR_MASK C2GSR_TXERR_MASK
#define C2GSR_TXERR_BIT 24
#define CAN2GSR_TXERR_BIT C2GSR_TXERR_BIT

#define C2ICR (*(volatile unsigned long *)0xE004800C)
#define CAN2ICR C2ICR
#define C2ICR_OFFSET 0xC
#define CAN2ICR_OFFSET C2ICR_OFFSET
#define C2ICR_RI_MASK 0x1
#define CAN2ICR_RI_MASK C2ICR_RI_MASK
#define C2ICR_RI 0x1
#define CAN2ICR_RI C2ICR_RI
#define C2ICR_RI_BIT 0
#define CAN2ICR_RI_BIT C2ICR_RI_BIT
#define C2ICR_TI1_MASK 0x2
#define CAN2ICR_TI1_MASK C2ICR_TI1_MASK
#define C2ICR_TI1 0x2
#define CAN2ICR_TI1 C2ICR_TI1
#define C2ICR_TI1_BIT 1
#define CAN2ICR_TI1_BIT C2ICR_TI1_BIT
#define C2ICR_EI_MASK 0x4
#define CAN2ICR_EI_MASK C2ICR_EI_MASK
#define C2ICR_EI 0x4
#define CAN2ICR_EI C2ICR_EI
#define C2ICR_EI_BIT 2
#define CAN2ICR_EI_BIT C2ICR_EI_BIT
#define C2ICR_DOI_MASK 0x8
#define CAN2ICR_DOI_MASK C2ICR_DOI_MASK
#define C2ICR_DOI 0x8
#define CAN2ICR_DOI C2ICR_DOI
#define C2ICR_DOI_BIT 3
#define CAN2ICR_DOI_BIT C2ICR_DOI_BIT
#define C2ICR_WUI_MASK 0x10
#define CAN2ICR_WUI_MASK C2ICR_WUI_MASK
#define C2ICR_WUI 0x10
#define CAN2ICR_WUI C2ICR_WUI
#define C2ICR_WUI_BIT 4
#define CAN2ICR_WUI_BIT C2ICR_WUI_BIT
#define C2ICR_EPI_MASK 0x20
#define CAN2ICR_EPI_MASK C2ICR_EPI_MASK
#define C2ICR_EPI 0x20
#define CAN2ICR_EPI C2ICR_EPI
#define C2ICR_EPI_BIT 5
#define CAN2ICR_EPI_BIT C2ICR_EPI_BIT
#define C2ICR_ALI_MASK 0x40
#define CAN2ICR_ALI_MASK C2ICR_ALI_MASK
#define C2ICR_ALI 0x40
#define CAN2ICR_ALI C2ICR_ALI
#define C2ICR_ALI_BIT 6
#define CAN2ICR_ALI_BIT C2ICR_ALI_BIT
#define C2ICR_BEI_MASK 0x80
#define CAN2ICR_BEI_MASK C2ICR_BEI_MASK
#define C2ICR_BEI 0x80
#define CAN2ICR_BEI C2ICR_BEI
#define C2ICR_BEI_BIT 7
#define CAN2ICR_BEI_BIT C2ICR_BEI_BIT
#define C2ICR_IDI_MASK 0x100
#define CAN2ICR_IDI_MASK C2ICR_IDI_MASK
#define C2ICR_IDI 0x100
#define CAN2ICR_IDI C2ICR_IDI
#define C2ICR_IDI_BIT 8
#define CAN2ICR_IDI_BIT C2ICR_IDI_BIT
#define C2ICR_TI2_MASK 0x200
#define CAN2ICR_TI2_MASK C2ICR_TI2_MASK
#define C2ICR_TI2 0x200
#define CAN2ICR_TI2 C2ICR_TI2
#define C2ICR_TI2_BIT 9
#define CAN2ICR_TI2_BIT C2ICR_TI2_BIT
#define C2ICR_TI3_MASK 0x400
#define CAN2ICR_TI3_MASK C2ICR_TI3_MASK
#define C2ICR_TI3 0x400
#define CAN2ICR_TI3 C2ICR_TI3
#define C2ICR_TI3_BIT 10
#define CAN2ICR_TI3_BIT C2ICR_TI3_BIT
#define C2ICR_ERRBIT_MASK 0x1F0000
#define CAN2ICR_ERRBIT_MASK C2ICR_ERRBIT_MASK
#define C2ICR_ERRBIT_BIT 16
#define CAN2ICR_ERRBIT_BIT C2ICR_ERRBIT_BIT
#define C2ICR_ERRDIR_MASK 0x200000
#define CAN2ICR_ERRDIR_MASK C2ICR_ERRDIR_MASK
#define C2ICR_ERRDIR 0x200000
#define CAN2ICR_ERRDIR C2ICR_ERRDIR
#define C2ICR_ERRDIR_BIT 21
#define CAN2ICR_ERRDIR_BIT C2ICR_ERRDIR_BIT
#define C2ICR_ERRC_MASK 0xC00000
#define CAN2ICR_ERRC_MASK C2ICR_ERRC_MASK
#define C2ICR_ERRC_BIT 22
#define CAN2ICR_ERRC_BIT C2ICR_ERRC_BIT
#define C2ICR_ALCBIT_MASK 0x1F000000
#define CAN2ICR_ALCBIT_MASK C2ICR_ALCBIT_MASK
#define C2ICR_ALCBIT_BIT 24
#define CAN2ICR_ALCBIT_BIT C2ICR_ALCBIT_BIT

#define C2IER (*(volatile unsigned long *)0xE0048010)
#define CAN2IER C2IER
#define C2IER_OFFSET 0x10
#define CAN2IER_OFFSET C2IER_OFFSET
#define C2IER_RIE_MASK 0x1
#define CAN2IER_RIE_MASK C2IER_RIE_MASK
#define C2IER_RIE 0x1
#define CAN2IER_RIE C2IER_RIE
#define C2IER_RIE_BIT 0
#define CAN2IER_RIE_BIT C2IER_RIE_BIT
#define C2IER_TIE1_MASK 0x2
#define CAN2IER_TIE1_MASK C2IER_TIE1_MASK
#define C2IER_TIE1 0x2
#define CAN2IER_TIE1 C2IER_TIE1
#define C2IER_TIE1_BIT 1
#define CAN2IER_TIE1_BIT C2IER_TIE1_BIT
#define C2IER_EIE_MASK 0x4
#define CAN2IER_EIE_MASK C2IER_EIE_MASK
#define C2IER_EIE 0x4
#define CAN2IER_EIE C2IER_EIE
#define C2IER_EIE_BIT 2
#define CAN2IER_EIE_BIT C2IER_EIE_BIT
#define C2IER_DOIE_MASK 0x8
#define CAN2IER_DOIE_MASK C2IER_DOIE_MASK
#define C2IER_DOIE 0x8
#define CAN2IER_DOIE C2IER_DOIE
#define C2IER_DOIE_BIT 3
#define CAN2IER_DOIE_BIT C2IER_DOIE_BIT
#define C2IER_WUIE_MASK 0x10
#define CAN2IER_WUIE_MASK C2IER_WUIE_MASK
#define C2IER_WUIE 0x10
#define CAN2IER_WUIE C2IER_WUIE
#define C2IER_WUIE_BIT 4
#define CAN2IER_WUIE_BIT C2IER_WUIE_BIT
#define C2IER_EPIE_MASK 0x20
#define CAN2IER_EPIE_MASK C2IER_EPIE_MASK
#define C2IER_EPIE 0x20
#define CAN2IER_EPIE C2IER_EPIE
#define C2IER_EPIE_BIT 5
#define CAN2IER_EPIE_BIT C2IER_EPIE_BIT
#define C2IER_ALIE_MASK 0x40
#define CAN2IER_ALIE_MASK C2IER_ALIE_MASK
#define C2IER_ALIE 0x40
#define CAN2IER_ALIE C2IER_ALIE
#define C2IER_ALIE_BIT 6
#define CAN2IER_ALIE_BIT C2IER_ALIE_BIT
#define C2IER_BEIE_MASK 0x80
#define CAN2IER_BEIE_MASK C2IER_BEIE_MASK
#define C2IER_BEIE 0x80
#define CAN2IER_BEIE C2IER_BEIE
#define C2IER_BEIE_BIT 7
#define CAN2IER_BEIE_BIT C2IER_BEIE_BIT
#define C2IER_IDIE_MASK 0x100
#define CAN2IER_IDIE_MASK C2IER_IDIE_MASK
#define C2IER_IDIE 0x100
#define CAN2IER_IDIE C2IER_IDIE
#define C2IER_IDIE_BIT 8
#define CAN2IER_IDIE_BIT C2IER_IDIE_BIT
#define C2IER_TIE2_MASK 0x200
#define CAN2IER_TIE2_MASK C2IER_TIE2_MASK
#define C2IER_TIE2 0x200
#define CAN2IER_TIE2 C2IER_TIE2
#define C2IER_TIE2_BIT 9
#define CAN2IER_TIE2_BIT C2IER_TIE2_BIT
#define C2IER_TIE3_MASK 0x400
#define CAN2IER_TIE3_MASK C2IER_TIE3_MASK
#define C2IER_TIE3 0x400
#define CAN2IER_TIE3 C2IER_TIE3
#define C2IER_TIE3_BIT 10
#define CAN2IER_TIE3_BIT C2IER_TIE3_BIT

#define C2BTR (*(volatile unsigned long *)0xE0048014)
#define CAN2BTR C2BTR
#define C2BTR_OFFSET 0x14
#define CAN2BTR_OFFSET C2BTR_OFFSET
#define C2BTR_BRP_MASK 0x3FF
#define CAN2BTR_BRP_MASK C2BTR_BRP_MASK
#define C2BTR_BRP_BIT 0
#define CAN2BTR_BRP_BIT C2BTR_BRP_BIT
#define C2BTR_SJW_MASK 0xC000
#define CAN2BTR_SJW_MASK C2BTR_SJW_MASK
#define C2BTR_SJW_BIT 14
#define CAN2BTR_SJW_BIT C2BTR_SJW_BIT
#define C2BTR_TSEG1_MASK 0xF0000
#define CAN2BTR_TSEG1_MASK C2BTR_TSEG1_MASK
#define C2BTR_TSEG1_BIT 16
#define CAN2BTR_TSEG1_BIT C2BTR_TSEG1_BIT
#define C2BTR_TSEG2_MASK 0x700000
#define CAN2BTR_TSEG2_MASK C2BTR_TSEG2_MASK
#define C2BTR_TSEG2_BIT 20
#define CAN2BTR_TSEG2_BIT C2BTR_TSEG2_BIT
#define C2BTR_SAM_MASK 0x800000
#define CAN2BTR_SAM_MASK C2BTR_SAM_MASK
#define C2BTR_SAM 0x800000
#define CAN2BTR_SAM C2BTR_SAM
#define C2BTR_SAM_BIT 23
#define CAN2BTR_SAM_BIT C2BTR_SAM_BIT

#define C2EWL (*(volatile unsigned long *)0xE0048018)
#define CAN2EWL C2EWL
#define C2EWL_OFFSET 0x18
#define CAN2EWL_OFFSET C2EWL_OFFSET
#define C2EWL_EWL_MASK 0xFF
#define CAN2EWL_EWL_MASK C2EWL_EWL_MASK
#define C2EWL_EWL_BIT 0
#define CAN2EWL_EWL_BIT C2EWL_EWL_BIT

#define C2SR (*(volatile unsigned long *)0xE004801C)
#define CAN2SR C2SR
#define C2SR_OFFSET 0x1C
#define CAN2SR_OFFSET C2SR_OFFSET
#define C2SR_RBS_MASK 0x1
#define CAN2SR_RBS_MASK C2SR_RBS_MASK
#define C2SR_RBS 0x1
#define CAN2SR_RBS C2SR_RBS
#define C2SR_RBS_BIT 0
#define CAN2SR_RBS_BIT C2SR_RBS_BIT
#define C2SR_DOS_MASK 0x2
#define CAN2SR_DOS_MASK C2SR_DOS_MASK
#define C2SR_DOS 0x2
#define CAN2SR_DOS C2SR_DOS
#define C2SR_DOS_BIT 1
#define CAN2SR_DOS_BIT C2SR_DOS_BIT
#define C2SR_TBS1_MASK 0x4
#define CAN2SR_TBS1_MASK C2SR_TBS1_MASK
#define C2SR_TBS1 0x4
#define CAN2SR_TBS1 C2SR_TBS1
#define C2SR_TBS1_BIT 2
#define CAN2SR_TBS1_BIT C2SR_TBS1_BIT
#define C2SR_TCS1_MASK 0x8
#define CAN2SR_TCS1_MASK C2SR_TCS1_MASK
#define C2SR_TCS1 0x8
#define CAN2SR_TCS1 C2SR_TCS1
#define C2SR_TCS1_BIT 3
#define CAN2SR_TCS1_BIT C2SR_TCS1_BIT
#define C2SR_RS_MASK 0x10
#define CAN2SR_RS_MASK C2SR_RS_MASK
#define C2SR_RS 0x10
#define CAN2SR_RS C2SR_RS
#define C2SR_RS_BIT 4
#define CAN2SR_RS_BIT C2SR_RS_BIT
#define C2SR_TS1_MASK 0x20
#define CAN2SR_TS1_MASK C2SR_TS1_MASK
#define C2SR_TS1 0x20
#define CAN2SR_TS1 C2SR_TS1
#define C2SR_TS1_BIT 5
#define CAN2SR_TS1_BIT C2SR_TS1_BIT
#define C2SR_ES_MASK 0x40
#define CAN2SR_ES_MASK C2SR_ES_MASK
#define C2SR_ES 0x40
#define CAN2SR_ES C2SR_ES
#define C2SR_ES_BIT 6
#define CAN2SR_ES_BIT C2SR_ES_BIT
#define C2SR_BS_MASK 0x80
#define CAN2SR_BS_MASK C2SR_BS_MASK
#define C2SR_BS 0x80
#define CAN2SR_BS C2SR_BS
#define C2SR_BS_BIT 7
#define CAN2SR_BS_BIT C2SR_BS_BIT
#define C2SR_RBS2_MASK 0x100
#define CAN2SR_RBS2_MASK C2SR_RBS2_MASK
#define C2SR_RBS2 0x100
#define CAN2SR_RBS2 C2SR_RBS2
#define C2SR_RBS2_BIT 8
#define CAN2SR_RBS2_BIT C2SR_RBS2_BIT
#define C2SR_DOS2_MASK 0x200
#define CAN2SR_DOS2_MASK C2SR_DOS2_MASK
#define C2SR_DOS2 0x200
#define CAN2SR_DOS2 C2SR_DOS2
#define C2SR_DOS2_BIT 9
#define CAN2SR_DOS2_BIT C2SR_DOS2_BIT
#define C2SR_TBS2_MASK 0x400
#define CAN2SR_TBS2_MASK C2SR_TBS2_MASK
#define C2SR_TBS2 0x400
#define CAN2SR_TBS2 C2SR_TBS2
#define C2SR_TBS2_BIT 10
#define CAN2SR_TBS2_BIT C2SR_TBS2_BIT
#define C2SR_TCS2_MASK 0x800
#define CAN2SR_TCS2_MASK C2SR_TCS2_MASK
#define C2SR_TCS2 0x800
#define CAN2SR_TCS2 C2SR_TCS2
#define C2SR_TCS2_BIT 11
#define CAN2SR_TCS2_BIT C2SR_TCS2_BIT
#define C2SR_RS2_MASK 0x1000
#define CAN2SR_RS2_MASK C2SR_RS2_MASK
#define C2SR_RS2 0x1000
#define CAN2SR_RS2 C2SR_RS2
#define C2SR_RS2_BIT 12
#define CAN2SR_RS2_BIT C2SR_RS2_BIT
#define C2SR_TS2_MASK 0x2000
#define CAN2SR_TS2_MASK C2SR_TS2_MASK
#define C2SR_TS2 0x2000
#define CAN2SR_TS2 C2SR_TS2
#define C2SR_TS2_BIT 13
#define CAN2SR_TS2_BIT C2SR_TS2_BIT
#define C2SR_ES2_MASK 0x4000
#define CAN2SR_ES2_MASK C2SR_ES2_MASK
#define C2SR_ES2 0x4000
#define CAN2SR_ES2 C2SR_ES2
#define C2SR_ES2_BIT 14
#define CAN2SR_ES2_BIT C2SR_ES2_BIT
#define C2SR_BS2_MASK 0x8000
#define CAN2SR_BS2_MASK C2SR_BS2_MASK
#define C2SR_BS2 0x8000
#define CAN2SR_BS2 C2SR_BS2
#define C2SR_BS2_BIT 15
#define CAN2SR_BS2_BIT C2SR_BS2_BIT
#define C2SR_RBS3_MASK 0x10000
#define CAN2SR_RBS3_MASK C2SR_RBS3_MASK
#define C2SR_RBS3 0x10000
#define CAN2SR_RBS3 C2SR_RBS3
#define C2SR_RBS3_BIT 16
#define CAN2SR_RBS3_BIT C2SR_RBS3_BIT
#define C2SR_DOS3_MASK 0x20000
#define CAN2SR_DOS3_MASK C2SR_DOS3_MASK
#define C2SR_DOS3 0x20000
#define CAN2SR_DOS3 C2SR_DOS3
#define C2SR_DOS3_BIT 17
#define CAN2SR_DOS3_BIT C2SR_DOS3_BIT
#define C2SR_TBS3_MASK 0x40000
#define CAN2SR_TBS3_MASK C2SR_TBS3_MASK
#define C2SR_TBS3 0x40000
#define CAN2SR_TBS3 C2SR_TBS3
#define C2SR_TBS3_BIT 18
#define CAN2SR_TBS3_BIT C2SR_TBS3_BIT
#define C2SR_TCS3_MASK 0x80000
#define CAN2SR_TCS3_MASK C2SR_TCS3_MASK
#define C2SR_TCS3 0x80000
#define CAN2SR_TCS3 C2SR_TCS3
#define C2SR_TCS3_BIT 19
#define CAN2SR_TCS3_BIT C2SR_TCS3_BIT
#define C2SR_RS3_MASK 0x100000
#define CAN2SR_RS3_MASK C2SR_RS3_MASK
#define C2SR_RS3 0x100000
#define CAN2SR_RS3 C2SR_RS3
#define C2SR_RS3_BIT 20
#define CAN2SR_RS3_BIT C2SR_RS3_BIT
#define C2SR_TS3_MASK 0x200000
#define CAN2SR_TS3_MASK C2SR_TS3_MASK
#define C2SR_TS3 0x200000
#define CAN2SR_TS3 C2SR_TS3
#define C2SR_TS3_BIT 21
#define CAN2SR_TS3_BIT C2SR_TS3_BIT
#define C2SR_ES3_MASK 0x400000
#define CAN2SR_ES3_MASK C2SR_ES3_MASK
#define C2SR_ES3 0x400000
#define CAN2SR_ES3 C2SR_ES3
#define C2SR_ES3_BIT 22
#define CAN2SR_ES3_BIT C2SR_ES3_BIT
#define C2SR_BS3_MASK 0x800000
#define CAN2SR_BS3_MASK C2SR_BS3_MASK
#define C2SR_BS3 0x800000
#define CAN2SR_BS3 C2SR_BS3
#define C2SR_BS3_BIT 23
#define CAN2SR_BS3_BIT C2SR_BS3_BIT

#define C2RFS (*(volatile unsigned long *)0xE0048020)
#define CAN2RFS C2RFS
#define C2RFS_OFFSET 0x20
#define CAN2RFS_OFFSET C2RFS_OFFSET
#define C2RFS_ID_Index_MASK 0x3FF
#define CAN2RFS_ID_Index_MASK C2RFS_ID_Index_MASK
#define C2RFS_ID_Index_BIT 0
#define CAN2RFS_ID_Index_BIT C2RFS_ID_Index_BIT
#define C2RFS_BP_MASK 0x400
#define CAN2RFS_BP_MASK C2RFS_BP_MASK
#define C2RFS_BP 0x400
#define CAN2RFS_BP C2RFS_BP
#define C2RFS_BP_BIT 10
#define CAN2RFS_BP_BIT C2RFS_BP_BIT
#define C2RFS_DLC_MASK 0xF0000
#define CAN2RFS_DLC_MASK C2RFS_DLC_MASK
#define C2RFS_DLC_BIT 16
#define CAN2RFS_DLC_BIT C2RFS_DLC_BIT
#define C2RFS_RTR_MASK 0x40000000
#define CAN2RFS_RTR_MASK C2RFS_RTR_MASK
#define C2RFS_RTR 0x40000000
#define CAN2RFS_RTR C2RFS_RTR
#define C2RFS_RTR_BIT 30
#define CAN2RFS_RTR_BIT C2RFS_RTR_BIT
#define C2RFS_FF_MASK 0x80000000
#define CAN2RFS_FF_MASK C2RFS_FF_MASK
#define C2RFS_FF 0x80000000
#define CAN2RFS_FF C2RFS_FF
#define C2RFS_FF_BIT 31
#define CAN2RFS_FF_BIT C2RFS_FF_BIT

#define C2RID (*(volatile unsigned long *)0xE0048024)
#define CAN2RID C2RID
#define C2RID_OFFSET 0x24
#define CAN2RID_OFFSET C2RID_OFFSET
#define C2RID_ID_MASK 0x7FF
#define CAN2RID_ID_MASK C2RID_ID_MASK
#define C2RID_ID_BIT 0
#define CAN2RID_ID_BIT C2RID_ID_BIT

#define C2RDA (*(volatile unsigned long *)0xE0048028)
#define CAN2RDA C2RDA
#define C2RDA_OFFSET 0x28
#define CAN2RDA_OFFSET C2RDA_OFFSET
#define C2RDA_Data_1_MASK 0xFF
#define CAN2RDA_Data_1_MASK C2RDA_Data_1_MASK
#define C2RDA_Data_1_BIT 0
#define CAN2RDA_Data_1_BIT C2RDA_Data_1_BIT
#define C2RDA_Data_2_MASK 0xFF00
#define CAN2RDA_Data_2_MASK C2RDA_Data_2_MASK
#define C2RDA_Data_2_BIT 8
#define CAN2RDA_Data_2_BIT C2RDA_Data_2_BIT
#define C2RDA_Data_3_MASK 0xFF0000
#define CAN2RDA_Data_3_MASK C2RDA_Data_3_MASK
#define C2RDA_Data_3_BIT 16
#define CAN2RDA_Data_3_BIT C2RDA_Data_3_BIT
#define C2RDA_Data_4_MASK 0xFF000000
#define CAN2RDA_Data_4_MASK C2RDA_Data_4_MASK
#define C2RDA_Data_4_BIT 24
#define CAN2RDA_Data_4_BIT C2RDA_Data_4_BIT

#define C2RDB (*(volatile unsigned long *)0xE004802C)
#define CAN2RDB C2RDB
#define C2RDB_OFFSET 0x2C
#define CAN2RDB_OFFSET C2RDB_OFFSET
#define C2RDB_Data_5_MASK 0xFF
#define CAN2RDB_Data_5_MASK C2RDB_Data_5_MASK
#define C2RDB_Data_5_BIT 0
#define CAN2RDB_Data_5_BIT C2RDB_Data_5_BIT
#define C2RDB_Data_6_MASK 0xFF00
#define CAN2RDB_Data_6_MASK C2RDB_Data_6_MASK
#define C2RDB_Data_6_BIT 8
#define CAN2RDB_Data_6_BIT C2RDB_Data_6_BIT
#define C2RDB_Data_7_MASK 0xFF0000
#define CAN2RDB_Data_7_MASK C2RDB_Data_7_MASK
#define C2RDB_Data_7_BIT 16
#define CAN2RDB_Data_7_BIT C2RDB_Data_7_BIT
#define C2RDB_Data_8_MASK 0xFF000000
#define CAN2RDB_Data_8_MASK C2RDB_Data_8_MASK
#define C2RDB_Data_8_BIT 24
#define CAN2RDB_Data_8_BIT C2RDB_Data_8_BIT

#define C2TFI1 (*(volatile unsigned long *)0xE0048030)
#define CAN2TFI1 C2TFI1
#define C2TFI1_OFFSET 0x30
#define CAN2TFI1_OFFSET C2TFI1_OFFSET
#define C2TFI1_PRIO_MASK 0xFF
#define CAN2TFI1_PRIO_MASK C2TFI1_PRIO_MASK
#define C2TFI1_PRIO_BIT 0
#define CAN2TFI1_PRIO_BIT C2TFI1_PRIO_BIT
#define C2TFI1_DLC_MASK 0xF0000
#define CAN2TFI1_DLC_MASK C2TFI1_DLC_MASK
#define C2TFI1_DLC_BIT 16
#define CAN2TFI1_DLC_BIT C2TFI1_DLC_BIT
#define C2TFI1_RTR_MASK 0x40000000
#define CAN2TFI1_RTR_MASK C2TFI1_RTR_MASK
#define C2TFI1_RTR 0x40000000
#define CAN2TFI1_RTR C2TFI1_RTR
#define C2TFI1_RTR_BIT 30
#define CAN2TFI1_RTR_BIT C2TFI1_RTR_BIT
#define C2TFI1_FF_MASK 0x80000000
#define CAN2TFI1_FF_MASK C2TFI1_FF_MASK
#define C2TFI1_FF 0x80000000
#define CAN2TFI1_FF C2TFI1_FF
#define C2TFI1_FF_BIT 31
#define CAN2TFI1_FF_BIT C2TFI1_FF_BIT

#define C2TID1 (*(volatile unsigned long *)0xE0048034)
#define CAN2TID1 C2TID1
#define C2TID1_OFFSET 0x34
#define CAN2TID1_OFFSET C2TID1_OFFSET
#define C2TID1_ID_MASK 0x7FF
#define CAN2TID1_ID_MASK C2TID1_ID_MASK
#define C2TID1_ID_BIT 0
#define CAN2TID1_ID_BIT C2TID1_ID_BIT

#define C2TDA1 (*(volatile unsigned long *)0xE0048038)
#define CAN2TDA1 C2TDA1
#define C2TDA1_OFFSET 0x38
#define CAN2TDA1_OFFSET C2TDA1_OFFSET
#define C2TDA1_Data_1_MASK 0xFF
#define CAN2TDA1_Data_1_MASK C2TDA1_Data_1_MASK
#define C2TDA1_Data_1_BIT 0
#define CAN2TDA1_Data_1_BIT C2TDA1_Data_1_BIT
#define C2TDA1_Data_2_MASK 0xFF00
#define CAN2TDA1_Data_2_MASK C2TDA1_Data_2_MASK
#define C2TDA1_Data_2_BIT 8
#define CAN2TDA1_Data_2_BIT C2TDA1_Data_2_BIT
#define C2TDA1_Data_3_MASK 0xFF0000
#define CAN2TDA1_Data_3_MASK C2TDA1_Data_3_MASK
#define C2TDA1_Data_3_BIT 16
#define CAN2TDA1_Data_3_BIT C2TDA1_Data_3_BIT
#define C2TDA1_Data_4_MASK 0xFF000000
#define CAN2TDA1_Data_4_MASK C2TDA1_Data_4_MASK
#define C2TDA1_Data_4_BIT 24
#define CAN2TDA1_Data_4_BIT C2TDA1_Data_4_BIT

#define C2TDB1 (*(volatile unsigned long *)0xE004803C)
#define CAN2TDB1 C2TDB1
#define C2TDB1_OFFSET 0x3C
#define CAN2TDB1_OFFSET C2TDB1_OFFSET
#define C2TDB1_Data_5_MASK 0xFF
#define CAN2TDB1_Data_5_MASK C2TDB1_Data_5_MASK
#define C2TDB1_Data_5_BIT 0
#define CAN2TDB1_Data_5_BIT C2TDB1_Data_5_BIT
#define C2TDB1_Data_6_MASK 0xFF00
#define CAN2TDB1_Data_6_MASK C2TDB1_Data_6_MASK
#define C2TDB1_Data_6_BIT 8
#define CAN2TDB1_Data_6_BIT C2TDB1_Data_6_BIT
#define C2TDB1_Data_7_MASK 0xFF0000
#define CAN2TDB1_Data_7_MASK C2TDB1_Data_7_MASK
#define C2TDB1_Data_7_BIT 16
#define CAN2TDB1_Data_7_BIT C2TDB1_Data_7_BIT
#define C2TDB1_Data_8_MASK 0xFF000000
#define CAN2TDB1_Data_8_MASK C2TDB1_Data_8_MASK
#define C2TDB1_Data_8_BIT 24
#define CAN2TDB1_Data_8_BIT C2TDB1_Data_8_BIT

#define C2TFI2 (*(volatile unsigned long *)0xE0048040)
#define CAN2TFI2 C2TFI2
#define C2TFI2_OFFSET 0x40
#define CAN2TFI2_OFFSET C2TFI2_OFFSET
#define C2TFI2_PRIO_MASK 0xFF
#define CAN2TFI2_PRIO_MASK C2TFI2_PRIO_MASK
#define C2TFI2_PRIO_BIT 0
#define CAN2TFI2_PRIO_BIT C2TFI2_PRIO_BIT
#define C2TFI2_DLC_MASK 0xF0000
#define CAN2TFI2_DLC_MASK C2TFI2_DLC_MASK
#define C2TFI2_DLC_BIT 16
#define CAN2TFI2_DLC_BIT C2TFI2_DLC_BIT
#define C2TFI2_RTR_MASK 0x40000000
#define CAN2TFI2_RTR_MASK C2TFI2_RTR_MASK
#define C2TFI2_RTR 0x40000000
#define CAN2TFI2_RTR C2TFI2_RTR
#define C2TFI2_RTR_BIT 30
#define CAN2TFI2_RTR_BIT C2TFI2_RTR_BIT
#define C2TFI2_FF_MASK 0x80000000
#define CAN2TFI2_FF_MASK C2TFI2_FF_MASK
#define C2TFI2_FF 0x80000000
#define CAN2TFI2_FF C2TFI2_FF
#define C2TFI2_FF_BIT 31
#define CAN2TFI2_FF_BIT C2TFI2_FF_BIT

#define C2TID2 (*(volatile unsigned long *)0xE0048044)
#define CAN2TID2 C2TID2
#define C2TID2_OFFSET 0x44
#define CAN2TID2_OFFSET C2TID2_OFFSET
#define C2TID2_ID_MASK 0x7FF
#define CAN2TID2_ID_MASK C2TID2_ID_MASK
#define C2TID2_ID_BIT 0
#define CAN2TID2_ID_BIT C2TID2_ID_BIT

#define C2TDA2 (*(volatile unsigned long *)0xE0048048)
#define CAN2TDA2 C2TDA2
#define C2TDA2_OFFSET 0x48
#define CAN2TDA2_OFFSET C2TDA2_OFFSET
#define C2TDA2_Data_1_MASK 0xFF
#define CAN2TDA2_Data_1_MASK C2TDA2_Data_1_MASK
#define C2TDA2_Data_1_BIT 0
#define CAN2TDA2_Data_1_BIT C2TDA2_Data_1_BIT
#define C2TDA2_Data_2_MASK 0xFF00
#define CAN2TDA2_Data_2_MASK C2TDA2_Data_2_MASK
#define C2TDA2_Data_2_BIT 8
#define CAN2TDA2_Data_2_BIT C2TDA2_Data_2_BIT
#define C2TDA2_Data_3_MASK 0xFF0000
#define CAN2TDA2_Data_3_MASK C2TDA2_Data_3_MASK
#define C2TDA2_Data_3_BIT 16
#define CAN2TDA2_Data_3_BIT C2TDA2_Data_3_BIT
#define C2TDA2_Data_4_MASK 0xFF000000
#define CAN2TDA2_Data_4_MASK C2TDA2_Data_4_MASK
#define C2TDA2_Data_4_BIT 24
#define CAN2TDA2_Data_4_BIT C2TDA2_Data_4_BIT

#define C2TDB2 (*(volatile unsigned long *)0xE004804C)
#define CAN2TDB2 C2TDB2
#define C2TDB2_OFFSET 0x4C
#define CAN2TDB2_OFFSET C2TDB2_OFFSET
#define C2TDB2_Data_5_MASK 0xFF
#define CAN2TDB2_Data_5_MASK C2TDB2_Data_5_MASK
#define C2TDB2_Data_5_BIT 0
#define CAN2TDB2_Data_5_BIT C2TDB2_Data_5_BIT
#define C2TDB2_Data_6_MASK 0xFF00
#define CAN2TDB2_Data_6_MASK C2TDB2_Data_6_MASK
#define C2TDB2_Data_6_BIT 8
#define CAN2TDB2_Data_6_BIT C2TDB2_Data_6_BIT
#define C2TDB2_Data_7_MASK 0xFF0000
#define CAN2TDB2_Data_7_MASK C2TDB2_Data_7_MASK
#define C2TDB2_Data_7_BIT 16
#define CAN2TDB2_Data_7_BIT C2TDB2_Data_7_BIT
#define C2TDB2_Data_8_MASK 0xFF000000
#define CAN2TDB2_Data_8_MASK C2TDB2_Data_8_MASK
#define C2TDB2_Data_8_BIT 24
#define CAN2TDB2_Data_8_BIT C2TDB2_Data_8_BIT

#define C2TFI3 (*(volatile unsigned long *)0xE0048050)
#define CAN2TFI3 C2TFI3
#define C2TFI3_OFFSET 0x50
#define CAN2TFI3_OFFSET C2TFI3_OFFSET
#define C2TFI3_PRIO_MASK 0xFF
#define CAN2TFI3_PRIO_MASK C2TFI3_PRIO_MASK
#define C2TFI3_PRIO_BIT 0
#define CAN2TFI3_PRIO_BIT C2TFI3_PRIO_BIT
#define C2TFI3_DLC_MASK 0xF0000
#define CAN2TFI3_DLC_MASK C2TFI3_DLC_MASK
#define C2TFI3_DLC_BIT 16
#define CAN2TFI3_DLC_BIT C2TFI3_DLC_BIT
#define C2TFI3_RTR_MASK 0x40000000
#define CAN2TFI3_RTR_MASK C2TFI3_RTR_MASK
#define C2TFI3_RTR 0x40000000
#define CAN2TFI3_RTR C2TFI3_RTR
#define C2TFI3_RTR_BIT 30
#define CAN2TFI3_RTR_BIT C2TFI3_RTR_BIT
#define C2TFI3_FF_MASK 0x80000000
#define CAN2TFI3_FF_MASK C2TFI3_FF_MASK
#define C2TFI3_FF 0x80000000
#define CAN2TFI3_FF C2TFI3_FF
#define C2TFI3_FF_BIT 31
#define CAN2TFI3_FF_BIT C2TFI3_FF_BIT

#define C2TID3 (*(volatile unsigned long *)0xE0048054)
#define CAN2TID3 C2TID3
#define C2TID3_OFFSET 0x54
#define CAN2TID3_OFFSET C2TID3_OFFSET
#define C2TID3_ID_MASK 0x7FF
#define CAN2TID3_ID_MASK C2TID3_ID_MASK
#define C2TID3_ID_BIT 0
#define CAN2TID3_ID_BIT C2TID3_ID_BIT

#define C2TDA3 (*(volatile unsigned long *)0xE0048058)
#define CAN2TDA3 C2TDA3
#define C2TDA3_OFFSET 0x58
#define CAN2TDA3_OFFSET C2TDA3_OFFSET
#define C2TDA3_Data_1_MASK 0xFF
#define CAN2TDA3_Data_1_MASK C2TDA3_Data_1_MASK
#define C2TDA3_Data_1_BIT 0
#define CAN2TDA3_Data_1_BIT C2TDA3_Data_1_BIT
#define C2TDA3_Data_2_MASK 0xFF00
#define CAN2TDA3_Data_2_MASK C2TDA3_Data_2_MASK
#define C2TDA3_Data_2_BIT 8
#define CAN2TDA3_Data_2_BIT C2TDA3_Data_2_BIT
#define C2TDA3_Data_3_MASK 0xFF0000
#define CAN2TDA3_Data_3_MASK C2TDA3_Data_3_MASK
#define C2TDA3_Data_3_BIT 16
#define CAN2TDA3_Data_3_BIT C2TDA3_Data_3_BIT
#define C2TDA3_Data_4_MASK 0xFF000000
#define CAN2TDA3_Data_4_MASK C2TDA3_Data_4_MASK
#define C2TDA3_Data_4_BIT 24
#define CAN2TDA3_Data_4_BIT C2TDA3_Data_4_BIT

#define C2TDB3 (*(volatile unsigned long *)0xE004805C)
#define CAN2TDB3 C2TDB3
#define C2TDB3_OFFSET 0x5C
#define CAN2TDB3_OFFSET C2TDB3_OFFSET
#define C2TDB3_Data_5_MASK 0xFF
#define CAN2TDB3_Data_5_MASK C2TDB3_Data_5_MASK
#define C2TDB3_Data_5_BIT 0
#define CAN2TDB3_Data_5_BIT C2TDB3_Data_5_BIT
#define C2TDB3_Data_6_MASK 0xFF00
#define CAN2TDB3_Data_6_MASK C2TDB3_Data_6_MASK
#define C2TDB3_Data_6_BIT 8
#define CAN2TDB3_Data_6_BIT C2TDB3_Data_6_BIT
#define C2TDB3_Data_7_MASK 0xFF0000
#define CAN2TDB3_Data_7_MASK C2TDB3_Data_7_MASK
#define C2TDB3_Data_7_BIT 16
#define CAN2TDB3_Data_7_BIT C2TDB3_Data_7_BIT
#define C2TDB3_Data_8_MASK 0xFF000000
#define CAN2TDB3_Data_8_MASK C2TDB3_Data_8_MASK
#define C2TDB3_Data_8_BIT 24
#define CAN2TDB3_Data_8_BIT C2TDB3_Data_8_BIT

struct LPC24_Can_Filter {
    uint32_t *matchFilters;
    uint32_t matchFiltersSize;

    uint32_t *lowerBoundFilters;
    uint32_t *upperBoundFilters;
    uint32_t groupFiltersSize;

};

typedef struct {
    uint32_t timeStampL;
    uint32_t timeStampH;

    uint32_t msgId;

    bool extendedId;
    bool remoteTransmissionRequest;

    uint32_t dataA;
    uint32_t dataB;

    int32_t length;

} LPC24_Can_Message;

struct LPC24_Can_Controller {
    const TinyCLR_Can_Provider* provider;

    LPC24_Can_Message *canRxMessagesFifo;

    TinyCLR_Can_ErrorReceivedHandler   errorEventHandler;
    TinyCLR_Can_MessageReceivedHandler    messageReceivedEventHandler;

    int32_t can_rx_count;
    int32_t can_rx_in;
    int32_t can_rx_out;

    int32_t can_max_messages_receiving;

    uint32_t baudrate;

    LPC24_Can_Filter canDataFilter;

};

static const LPC24_Gpio_Pin g_LPC24_Can_Tx_Pins[] = LPC24_CAN_TX_PINS;
static const LPC24_Gpio_Pin g_LPC24_Can_Rx_Pins[] = LPC24_CAN_RX_PINS;

static const int TOTAL_CAN_CONTROLLERS = SIZEOF_ARRAY(g_LPC24_Can_Tx_Pins);

static LPC24_Can_Controller canController[TOTAL_CAN_CONTROLLERS];

static TinyCLR_Can_Provider *canProvider[TOTAL_CAN_CONTROLLERS];
static TinyCLR_Api_Info canApi;

static uint8_t canProviderDefs[TOTAL_CAN_CONTROLLERS * sizeof(TinyCLR_Can_Provider)];

void CAN_DisableExplicitFilters(int32_t channel) {
    DISABLE_INTERRUPTS_SCOPED(irq);

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    if (canController[channel].canDataFilter.matchFiltersSize && canController[channel].canDataFilter.matchFilters != nullptr) {
        memoryProvider->Free(memoryProvider, canController[channel].canDataFilter.matchFilters);

        canController[channel].canDataFilter.matchFiltersSize = 0;
    }
}

void CAN_DisableGroupFilters(int32_t channel) {
    DISABLE_INTERRUPTS_SCOPED(irq);

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    if (canController[channel].canDataFilter.groupFiltersSize) {
        if (canController[channel].canDataFilter.lowerBoundFilters != nullptr)
            memoryProvider->Free(memoryProvider, canController[channel].canDataFilter.lowerBoundFilters);

        if (canController[channel].canDataFilter.upperBoundFilters != nullptr)
            memoryProvider->Free(memoryProvider, canController[channel].canDataFilter.upperBoundFilters);

        canController[channel].canDataFilter.groupFiltersSize = 0;
    }
}

/******************************************************************************
** Function name:        CAN_SetACCF_Lookup
**
** Descriptions:        Initialize CAN, install CAN interrupt handler
**
** parameters:            bitrate
** Returned value:        true or false, false if initialization failed.
**
******************************************************************************/
void CAN_SetACCF_Lookup(void) {
    uint32_t address = 0;
    uint32_t i;
    uint32_t ID_high, ID_low;

    // Set explicit standard Frame
    SFF_sa = address;
    for (i = 0; i < ACCF_IDEN_NUM; i += 2) {
        ID_low = (i << 29) | (EXP_STD_ID << 16);
        ID_high = ((i + 1) << 13) | (EXP_STD_ID << 0);
        *((volatile uint32_t *)(CAN_MEM_BASE + address)) = ID_low | ID_high;
        address += 4;
    }

    // Set group standard Frame
    SFF_GRP_sa = address;
    for (i = 0; i < ACCF_IDEN_NUM; i += 2) {
        ID_low = (i << 29) | (GRP_STD_ID << 16);
        ID_high = ((i + 1) << 13) | (GRP_STD_ID << 0);
        *((volatile uint32_t *)(CAN_MEM_BASE + address)) = ID_low | ID_high;
        address += 4;
    }

    // Set explicit extended Frame
    EFF_sa = address;
    for (i = 0; i < ACCF_IDEN_NUM; i++) {
        ID_low = (i << 29) | (EXP_EXT_ID << 0);
        *((volatile uint32_t *)(CAN_MEM_BASE + address)) = ID_low;
        address += 4;
    }

    // Set group extended Frame
    EFF_GRP_sa = address;
    for (i = 0; i < ACCF_IDEN_NUM; i++) {
        ID_low = (i << 29) | (GRP_EXT_ID << 0);
        *((volatile uint32_t *)(CAN_MEM_BASE + address)) = ID_low;
        address += 4;
    }

    // Set End of Table
    ENDofTable = address;
    return;
}

/******************************************************************************
** Function name:        CAN_SetACCF
**
** Descriptions:        Set acceptance filter and SRAM associated with
**
** parameters:            ACMF mode
** Returned value:        None
**
**
******************************************************************************/
void CAN_SetACCF(uint32_t ACCFMode) {
    switch (ACCFMode) {
    case ACCF_OFF:
        AFMR = ACCFMode;
        C1MOD = C2MOD = 1;    // Reset CAN
        C1IER = C2IER = 0;    // Disable Receive Interrupt
        C1GSR = C2GSR = 0;    // Reset error counter when CANxMOD is in reset
        break;

    case ACCF_BYPASS:
        AFMR = ACCFMode;
        break;

    case ACCF_ON:
    case ACCF_FULLCAN:
        AFMR = ACCF_OFF;
        CAN_SetACCF_Lookup();
        AFMR = ACCFMode;
        break;

    default:
        break;
    }
    return;
}

bool InsertionSort2CheckOverlap(uint32_t *lowerBounds, uint32_t *upperBounds, int32_t length) {

    uint32_t i, j, tmp, tmp2;

    for (i = 1; i < length; i++) {
        j = i;

        while (j > 0 && lowerBounds[j - 1] > lowerBounds[j]) {
            tmp = lowerBounds[j]; tmp2 = upperBounds[j];
            lowerBounds[j] = lowerBounds[j - 1];    upperBounds[j] = upperBounds[j - 1];
            lowerBounds[j - 1] = tmp;    upperBounds[j - 1] = tmp2;

            j--;
        }
    }

    // check for overlap
    if (lowerBounds[0] > upperBounds[0])
        return false;

    for (i = 1; i < length; i++) {
        if (lowerBounds[i] > upperBounds[i])
            return false;

        if (lowerBounds[i] <= upperBounds[i - 1])
            return false;
    }

    return true;
}

int32_t BinarySearch(uint32_t *sortedArray, int32_t first, int32_t last, uint32_t key) {
    int32_t mid;
    while (first <= last) {
        mid = (first + last) / 2;  // compute mid point.
        if (key > sortedArray[mid])
            first = mid + 1;  // repeat search in top half.
        else if (key < sortedArray[mid])
            last = mid - 1; // repeat search in bottom half.
        else
            return mid;     // found it. return position /////
    }

    return -1;    // failed to find key
}

int32_t BinarySearch2(uint32_t *lowerBounds, uint32_t *upperBounds, int32_t first, int32_t last, uint32_t key) {

    int32_t mid;

    while (first <= last) {
        mid = (first + last) / 2;  // compute mid point.

        if (key > upperBounds[mid])
            first = mid + 1;  // repeat search in top half.
        else if (key < lowerBounds[mid])
            last = mid - 1; // repeat search in bottom half.
        else
            return mid;     // found it. return position /////
    }

    return -1;    // failed to find key
}

const TinyCLR_Api_Info* LPC24_Can_GetApi() {
    for (int i = 0; i < TOTAL_CAN_CONTROLLERS; i++) {
        canProvider[i] = (TinyCLR_Can_Provider*)(canProviderDefs + (i * sizeof(TinyCLR_Can_Provider)));
        canProvider[i]->Parent = &canApi;
        canProvider[i]->Index = i;
        canProvider[i]->Acquire = &LPC24_Can_Acquire;
        canProvider[i]->Release = &LPC24_Can_Release;
        canProvider[i]->Reset = &LPC24_Can_Reset;
        canProvider[i]->WriteMessage = &LPC24_Can_WriteMessage;
        canProvider[i]->ReadMessage = &LPC24_Can_ReadMessage;
        canProvider[i]->SetBitTiming = &LPC24_Can_SetBitTiming;
        canProvider[i]->GetUnreadMessageCount = &LPC24_Can_GetUnreadMessageCount;
        canProvider[i]->SetMessageReceivedHandler = &LPC24_Can_SetMessageReceivedHandler;
        canProvider[i]->SetErrorReceivedHandler = &LPC24_Can_SetErrorReceivedHandler;
        canProvider[i]->SetExplicitFilters = &LPC24_Can_SetExplicitFilters;
        canProvider[i]->SetGroupFilters = &LPC24_Can_SetGroupFilters;
        canProvider[i]->DiscardUnreadMessages = &LPC24_Can_DiscardUnreadMessages;
        canProvider[i]->IsSendingAllowed = &LPC24_Can_IsSendingAllowed;
        canProvider[i]->GetWriteErrorCount = &LPC24_Can_GetWriteErrorCount;
        canProvider[i]->GetReadErrorCount = &LPC24_Can_GetReadErrorCount;
        canProvider[i]->GetSourceClock = &LPC24_Can_GetSourceClock;
        canProvider[i]->SetReadBufferSize = &LPC24_Can_SetReadBufferSize;
    }

    canApi.Author = "GHI Electronics, LLC";
    canApi.Name = "GHIElectronics.TinyCLR.NativeApis.LPC24.CanProvider";
    canApi.Type = TinyCLR_Api_Type::CanProvider;
    canApi.Version = 0;
    canApi.Count = TOTAL_CAN_CONTROLLERS;
    canApi.Implementation = canProvider;

    return &canApi;
}

uint32_t LPC24_Can_GetLocalTime() {
    return LPC24_Time_GetTimeForProcessorTicks(nullptr, LPC24_Time_GetCurrentTicks(nullptr));
}

/******************************************************************************
** Function name:        CAN_ISR_Rx
**
** Descriptions:        CAN Rx1 interrupt handler
**
** parameters:            None
** Returned value:        None
**
******************************************************************************/
void CAN_ISR_Rx(int32_t channel) {
    // filter
    if (canController[channel].canDataFilter.groupFiltersSize || canController[channel].canDataFilter.matchFiltersSize) {
        uint32_t ID = channel == 0 ? C1RID : C2RID;

        char passed = 0;

        if (canController[channel].canDataFilter.groupFiltersSize) {
            if (BinarySearch2(canController[channel].canDataFilter.lowerBoundFilters, canController[channel].canDataFilter.upperBoundFilters, 0, canController[channel].canDataFilter.groupFiltersSize - 1, ID) >= 0)
                passed = 1;
        }

        if (!passed && canController[channel].canDataFilter.matchFiltersSize) {
            if (BinarySearch(canController[channel].canDataFilter.matchFilters, 0, canController[channel].canDataFilter.matchFiltersSize - 1, ID) >= 0)
                passed = 1;
        }

        if (!passed) {
            if (channel == 0)
                C1CMR = 0x04; // release receive buffer
            else
                C2CMR = 0x04; // release receive buffer
            return;
        }
    }

    if (canController[channel].can_rx_count > (canController[channel].can_max_messages_receiving - 3)) {
        if (channel == 0)
            C1CMR = 0x04; // release receive buffer
        else
            C2CMR = 0x04; // release receive buffer

        auto interop = (const TinyCLR_Interop_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::InteropProvider);

        canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::ReadBufferFull);

        return;
    }

    // initialize destination pointer
    LPC24_Can_Message *can_msg = &canController[channel].canRxMessagesFifo[canController[channel].can_rx_in];

    // timestamp
    uint64_t t = LPC24_Can_GetLocalTime();

    can_msg->timeStampL = t & 0xFFFFFFFF;
    can_msg->timeStampH = t >> 32;

    uint32_t flag;
    uint32_t dataA;
    uint32_t dataB;
    uint32_t msgId;

    if (channel == 0) {
        flag = C1RFS;  // Frame
        msgId = C1RID;
        dataA = C1RDA;
        dataB = C1RDB;
        C1CMR = 0x04; // release receive buffer
    }
    else {
        flag = C2RFS;  // Frame
        msgId = C2RID;
        dataA = C2RDA;
        dataB = C2RDB;
        C2CMR = 0x04; // release receive buffer
    }

    can_msg->length = (flag >> 16) & 0x0F;

    can_msg->extendedId = ((flag & 0x80000000) != 0) ? true : false;

    can_msg->remoteTransmissionRequest = ((flag & 0x40000000) != 0) ? true : false;

    can_msg->msgId = msgId; // ID

    can_msg->dataA = dataA; // Data A

    can_msg->dataB = dataB; // Data B

    canController[channel].can_rx_count++;
    canController[channel].can_rx_in++;

    if (canController[channel].can_rx_in == canController[channel].can_max_messages_receiving) {
        canController[channel].can_rx_in = 0;
    }

    auto interop = (const TinyCLR_Interop_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::InteropProvider);

    canController[channel].messageReceivedEventHandler(interop, canController[channel].provider, canController[channel].can_rx_count);
}
void LPC24_Can_RxInterruptHandler(void *param) {
    uint32_t status = CANRxSR;

    int32_t channel;

    DISABLE_INTERRUPTS_SCOPED(irq);

    auto interop = (const TinyCLR_Interop_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::InteropProvider);

    if (status & (1 << 8)) {
        channel = 0;

        uint32_t c1 = CAN1ICR;

        CAN_ISR_Rx(channel);

        if (c1 & (1 << 3)) {
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::ReadBufferOverrun);
        }
        if (c1 & (1 << 5)) {
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::Passive);
        }
        if (c1 & (1 << 7)) {
            C1MOD = 1;    // Reset CAN
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::BusOff);
        }

    }
    if (status & (1 << 9)) {
        channel = 1;

        uint32_t c2 = CAN2ICR;

        CAN_ISR_Rx(channel);

        if (c2 & (1 << 3)) {
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::ReadBufferOverrun);
        }
        if (c2 & (1 << 5)) {
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::Passive);
        }
        if (c2 & (1 << 7)) {
            C2MOD = 1;    // Reset CAN
            canController[channel].errorEventHandler(interop, canController[channel].provider, TinyCLR_Can_Error::BusOff);
        }
    }
}

TinyCLR_Result LPC24_Can_Acquire(const TinyCLR_Can_Provider* self) {
    if (self == nullptr)
        return TinyCLR_Result::ArgumentNull;

    int32_t channel = self->Index;

    if (!LPC24_Gpio_OpenPin(g_LPC24_Can_Tx_Pins[channel].number))
        return TinyCLR_Result::SharingViolation;

    if (!LPC24_Gpio_OpenPin(g_LPC24_Can_Rx_Pins[channel].number))
        return TinyCLR_Result::SharingViolation;

    // set pin as analog
    LPC24_Gpio_ConfigurePin(g_LPC24_Can_Tx_Pins[channel].number, LPC24_Gpio_Direction::Input, g_LPC24_Can_Tx_Pins[channel].pinFunction, LPC24_Gpio_PinMode::Inactive);
    LPC24_Gpio_ConfigurePin(g_LPC24_Can_Rx_Pins[channel].number, LPC24_Gpio_Direction::Input, g_LPC24_Can_Rx_Pins[channel].pinFunction, LPC24_Gpio_PinMode::Inactive);

    canController[channel].can_rx_count = 0;
    canController[channel].can_rx_in = 0;
    canController[channel].can_rx_out = 0;
    canController[channel].baudrate = 0;
    canController[channel].can_max_messages_receiving = LPC24_CAN_RX_BUFFER_DEFAULT_SIZE;
    canController[channel].provider = self;

    canController[channel].canDataFilter.matchFiltersSize = 0;
    canController[channel].canDataFilter.groupFiltersSize = 0;

    if (channel == 0)
        LPC24XX::SYSCON().PCONP |= (1 << 13);    // Enable clock to the peripheral

    if (channel == 1)
        LPC24XX::SYSCON().PCONP |= (1 << 14);    // Enable clock to the peripheral

    CAN_SetACCF(ACCF_BYPASS);

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_Release(const TinyCLR_Can_Provider* self) {
    if (self == nullptr)
        return TinyCLR_Result::ArgumentNull;

    int32_t channel = self->Index;

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    TinyCLR_Result releasePin = LPC24_Gpio_ReleasePin(nullptr, g_LPC24_Can_Tx_Pins[channel].number);

    if (releasePin != TinyCLR_Result::Success)
        return releasePin;

    releasePin = LPC24_Gpio_ReleasePin(nullptr, g_LPC24_Can_Rx_Pins[channel].number);

    if (releasePin != TinyCLR_Result::Success)
        return releasePin;

    // free pin
    LPC24_Gpio_ClosePin(g_LPC24_Can_Tx_Pins[channel].number);
    LPC24_Gpio_ClosePin(g_LPC24_Can_Rx_Pins[channel].number);

    if (canController[channel].canRxMessagesFifo != nullptr)
        memoryProvider->Free(memoryProvider, canController[channel].canRxMessagesFifo);

    CAN_DisableExplicitFilters(channel);
    CAN_DisableGroupFilters(channel);

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_Reset(const TinyCLR_Can_Provider* self) {
    int32_t channel = self->Index;

    canController[channel].can_rx_count = 0;
    canController[channel].can_rx_in = 0;
    canController[channel].can_rx_out = 0;

    // Reset CAN
    if (channel == 0) {
        C1MOD = 1;    // Reset CAN
        C1IER = 0;    // Disable Receive Interrupt
        C1GSR = 0;    // Reset error counter when CANxMOD is in reset
        C1BTR = canController[channel].baudrate;
        C1MOD = 0x4;    // CAN in normal operation mode
        C1IER = 0x01 | (1 << 7) | (1 << 3) | (1 << 5);    // Enable receive interrupts

    }
    else {
        C2MOD = 1;    // Reset CAN
        C2IER = 0;    // Disable Receive Interrupt
        C2GSR = 0;    // Reset error counter when CANxMOD is in reset
        C2BTR = canController[channel].baudrate;
        C2MOD = 0x4;    // CAN in normal operation mode
        C2IER = 0x01 | (1 << 7) | (1 << 3) | (1 << 5);    // Enable receive interrupts
    }

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_WriteMessage(const TinyCLR_Can_Provider* self, uint32_t arbitrationId, bool isExtendedId, bool isRemoteTransmissionRequest, uint8_t* data, size_t length) {

    uint32_t *data32 = (uint32_t*)data;

    uint32_t flags = 0;
    uint32_t status;

    int32_t channel = self->Index;

    if (isExtendedId)
        flags |= 0x80000000;

    if (isRemoteTransmissionRequest)
        flags |= 0x40000000;

    flags |= (length & 0x0F) << 16;

    bool readyToSend = false;

    uint32_t timeout = CAN_TRANSFER_TIMEOUT;

    while (readyToSend == false && timeout > 0) {
        LPC24_Can_IsSendingAllowed(self, readyToSend);
        timeout--;
    }

    if (timeout == 0)
        return TinyCLR_Result::Busy;

    if (channel == 0) {
        status = C1SR;

        if (status & 0x00000004) {
            C1TFI1 = flags & 0xC00F0000;
            C1TID1 = arbitrationId;
            C1TDA1 = data32[0];
            C1TDB1 = data32[1];

            C1CMR = 0x21;

            return TinyCLR_Result::Success;
        }
    }
    else {
        status = C2SR;

        if (status & 0x00000004) {
            C2TFI1 = flags & 0xC00F0000;
            C2TID1 = arbitrationId;
            C2TDA1 = data32[0];
            C2TDB1 = data32[1];

            C2CMR = 0x21;

            return TinyCLR_Result::Success;
        }
    }

    return TinyCLR_Result::Busy;
}

TinyCLR_Result LPC24_Can_ReadMessage(const TinyCLR_Can_Provider* self, uint32_t& arbitrationId, bool& isExtendedId, bool& isRemoteTransmissionRequest, uint64_t& timestamp, uint8_t* data, size_t& length) {
    LPC24_Can_Message *can_msg;

    uint32_t *data32 = (uint32_t*)data;

    int32_t channel = self->Index;

    if (canController[channel].can_rx_count) {
        DISABLE_INTERRUPTS_SCOPED(irq);

        can_msg = &canController[channel].canRxMessagesFifo[canController[channel].can_rx_out];
        canController[channel].can_rx_out++;

        if (canController[channel].can_rx_out == canController[channel].can_max_messages_receiving)
            canController[channel].can_rx_out = 0;

        canController[channel].can_rx_count--;

        arbitrationId = can_msg->msgId;
        isExtendedId = can_msg->extendedId;
        isRemoteTransmissionRequest = can_msg->remoteTransmissionRequest;

        data32[0] = can_msg->dataA;
        data32[1] = can_msg->dataB;

        length = can_msg->length;

        timestamp = ((uint64_t)can_msg->timeStampL) | ((uint64_t)can_msg->timeStampH << 32);
    }

    return TinyCLR_Result::Success;

}

TinyCLR_Result LPC24_Can_SetBitTiming(const TinyCLR_Can_Provider* self, int32_t propagation, int32_t phase1, int32_t phase2, int32_t baudratePrescaler, int32_t synchronizationJumpWidth, int8_t useMultiBitSampling) {
    int32_t channel = self->Index;

    LPC24XX_SYSCON &SYSCON = *(LPC24XX_SYSCON *)(size_t)(LPC24XX_SYSCON::c_SYSCON_Base);

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    canController[channel].canRxMessagesFifo = (LPC24_Can_Message*)memoryProvider->Allocate(memoryProvider, canController[channel].can_max_messages_receiving * sizeof(LPC24_Can_Message));

    if (canController[channel].canRxMessagesFifo == nullptr) {
        return TinyCLR_Result::OutOfMemory;
    }

    canController[channel].baudrate = ((phase2 - 1) << 20) | ((phase1 - 1) << 16) | ((baudratePrescaler - 1) << 0);

    if (channel == 0) {
        SYSCON.PCLKSEL0 |= (1 << 26) | (1 << 30);//CAN1 CAN2 filter

        C1MOD = 1;    // Reset CAN
        C1IER = 0;    // Disable Receive Interrupt
        C1GSR = 0;    // Reset error counter when CANxMOD is in reset

        C1BTR = canController[channel].baudrate;

        C1MOD = 0x4;    // CAN in normal operation mode

        C1IER = 0x01 | (1 << 7) | (1 << 3) | (1 << 5);    // Enable receive interrupts
    }
    else {
        SYSCON.PCLKSEL0 |= (1 << 28) | (1 << 30);//CAN1 CAN2 filter

        C2MOD = 1;    // Reset CAN
        C2IER = 0;    // Disable Receive Interrupt
        C2GSR = 0;    // Reset error counter when CANxMOD is in reset

        C2BTR = canController[channel].baudrate;

        C2MOD = 0x0;    // CAN in normal operation mode
        C2IER = 0x01 | (1 << 3) | (1 << 5) | (1 << 7);        // Enable receive interrupts

    }

    LPC24_Interrupt_Activate(LPC24XX_VIC::c_IRQ_INDEX_CAN, (uint32_t*)&LPC24_Can_RxInterruptHandler, 0);

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_GetUnreadMessageCount(const TinyCLR_Can_Provider* self, size_t& count) {
    int32_t channel = self->Index;

    count = canController[channel].can_rx_count;

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_SetMessageReceivedHandler(const TinyCLR_Can_Provider* self, TinyCLR_Can_MessageReceivedHandler handler) {
    int32_t channel = self->Index;

    canController[channel].messageReceivedEventHandler = handler;

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_SetErrorReceivedHandler(const TinyCLR_Can_Provider* self, TinyCLR_Can_ErrorReceivedHandler handler) {
    int32_t channel = self->Index;

    canController[channel].errorEventHandler = handler;

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_SetExplicitFilters(const TinyCLR_Can_Provider* self, uint8_t* filters, size_t length) {
    uint32_t *_matchFilters;
    uint32_t *filters32 = (uint32_t*)filters;

    int32_t channel = self->Index;

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    _matchFilters = (uint32_t*)memoryProvider->Allocate(memoryProvider, length * sizeof(uint32_t));

    if (!_matchFilters)
        return TinyCLR_Result::OutOfMemory;

    memcpy(_matchFilters, filters32, length * sizeof(uint32_t));

    std::sort(_matchFilters, _matchFilters + length);

    {
        DISABLE_INTERRUPTS_SCOPED(irq);

        CAN_DisableExplicitFilters(channel);

        canController[channel].canDataFilter.matchFiltersSize = length;
        canController[channel].canDataFilter.matchFilters = _matchFilters;
    }

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_SetGroupFilters(const TinyCLR_Can_Provider* self, uint8_t* lowerBounds, uint8_t* upperBounds, size_t length) {
    uint32_t *_lowerBoundFilters, *_upperBoundFilters;
    uint32_t *lowerBounds32 = (uint32_t *)lowerBounds;
    uint32_t *upperBounds32 = (uint32_t *)upperBounds;

    auto memoryProvider = (const TinyCLR_Memory_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::MemoryProvider);

    int32_t channel = self->Index;

    _lowerBoundFilters = (uint32_t*)memoryProvider->Allocate(memoryProvider, length * sizeof(uint32_t));
    _upperBoundFilters = (uint32_t*)memoryProvider->Allocate(memoryProvider, length * sizeof(uint32_t));

    if (!_lowerBoundFilters || !_upperBoundFilters) {
        memoryProvider->Free(memoryProvider, _lowerBoundFilters);
        memoryProvider->Free(memoryProvider, _upperBoundFilters);

        return  TinyCLR_Result::OutOfMemory;
    }

    memcpy(_lowerBoundFilters, lowerBounds32, length * sizeof(uint32_t));
    memcpy(_upperBoundFilters, upperBounds32, length * sizeof(uint32_t));

    bool success = InsertionSort2CheckOverlap(_lowerBoundFilters, _upperBoundFilters, length);

    if (!success) {
        memoryProvider->Free(memoryProvider, _lowerBoundFilters);
        memoryProvider->Free(memoryProvider, _upperBoundFilters);

        return TinyCLR_Result::ArgumentInvalid;
    }

    {
        DISABLE_INTERRUPTS_SCOPED(irq);

        CAN_DisableGroupFilters(channel);

        canController[channel].canDataFilter.groupFiltersSize = length;
        canController[channel].canDataFilter.lowerBoundFilters = _lowerBoundFilters;
        canController[channel].canDataFilter.upperBoundFilters = _upperBoundFilters;
    }

    return TinyCLR_Result::Success;;
}

TinyCLR_Result LPC24_Can_DiscardUnreadMessages(const TinyCLR_Can_Provider* self) {
    int32_t channel = self->Index;

    canController[channel].can_rx_count = 0;
    canController[channel].can_rx_in = 0;
    canController[channel].can_rx_out = 0;

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_IsSendingAllowed(const TinyCLR_Can_Provider* self, bool& allowed) {
    int32_t channel = self->Index;

    uint32_t status = 0;

    allowed = false;

    status = channel == 0 ? C1SR : C2SR;

    if ((status & 0x00000004) &&
        (status & 0x00000400) &&
        (status & 0x00040000)) {
        allowed = true;
    }

    return TinyCLR_Result::Success;
}

TinyCLR_Result LPC24_Can_GetReadErrorCount(const TinyCLR_Can_Provider* self, size_t& count) {
    int32_t channel = self->Index;

    count = channel == 0 ? ((C1GSR >> 16) & 0xFF) : ((C2GSR >> 16) & 0xFF);

    return TinyCLR_Result::Success;;
}

TinyCLR_Result LPC24_Can_GetWriteErrorCount(const TinyCLR_Can_Provider* self, size_t& count) {
    int32_t channel = self->Index;

    count = channel == 0 ? (C1GSR >> 24) : (C2GSR >> 24);

    return TinyCLR_Result::Success;;
}

TinyCLR_Result LPC24_Can_GetSourceClock(const TinyCLR_Can_Provider* self, uint32_t& sourceClock) {
    sourceClock = LPC24_AHB_CLOCK_HZ;

    return TinyCLR_Result::Success;;
}

TinyCLR_Result LPC24_Can_SetReadBufferSize(const TinyCLR_Can_Provider* self, size_t size) {
    int32_t channel = self->Index;

    if (size > 3) {
        canController[channel].can_max_messages_receiving = size;
        return TinyCLR_Result::Success;;
    }
    else {
        canController[channel].can_max_messages_receiving = LPC24_CAN_RX_BUFFER_DEFAULT_SIZE;
        return TinyCLR_Result::ArgumentInvalid;;
    }
}

#endif // INCLUDE_CAN
